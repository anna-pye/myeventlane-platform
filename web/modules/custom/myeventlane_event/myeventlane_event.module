<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\myeventlane_event\Form\EventFormAlter;

/**
 * Implements hook_form_alter() for event node forms.
 */
function myeventlane_event_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  if (str_contains($form_id, 'node_event')) {
    $service = \Drupal::service('myeventlane_event.form_alter');
    if ($service instanceof EventFormAlter) {
      $service->alterForm($form, $form_state, $form_id);
    }
  }
}

/**
 * Implements hook_entity_view().
 */
function myeventlane_event_entity_view(array &$build, EntityInterface $entity, \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display, $view_mode): void {
  if ($entity->getEntityTypeId() !== 'node') {
    return;
  }
  if ($entity->bundle() !== 'event') {
    return;
  }
  if ($view_mode !== 'full') {
    return;
  }

  $build['#attached']['library'][] = 'myeventlane_event/event_node';
}

/**
 * Implements hook_ENTITY_TYPE_view_alter() for node entities.
 *
 * Modifies event node build array before rendering to:
 * - Hide default field_category rendering (we use colored pills instead)
 * - Ensure map render array is in content region so it's accessible in Twig
 */
function myeventlane_event_node_view_alter(array &$build, EntityInterface $entity, $display): void {
  if (!$entity instanceof NodeInterface || $entity->bundle() !== 'event') {
    return;
  }

  $view_mode = $build['#view_mode'] ?? 'full';
  if ($view_mode !== 'full') {
    return;
  }

  // Hide default category field rendering - we'll use colored pills instead.
  if (isset($build['field_category'])) {
    $build['field_category']['#access'] = FALSE;
  }
  // Also hide it in content region if it exists there.
  if (isset($build['content']['field_category'])) {
    $build['content']['field_category']['#access'] = FALSE;
  }

  // Ensure event_location_map is in the content region so it's accessible in Twig.
  // myeventlane_location adds it to the root build array, but we need it in content.
  if (isset($build['event_location_map'])) {
    $build['content']['event_location_map'] = $build['event_location_map'];
    // Optionally remove from root to avoid duplication (though it won't render unless in content).
    unset($build['event_location_map']);
  }
  if (isset($build['event_location_info'])) {
    $build['content']['event_location_info'] = $build['event_location_info'];
    unset($build['event_location_info']);
  }
}

/**
 * Implements hook_preprocess_node().
 *
 * Ensures field_ticket_types is available in content array for full view mode,
 * even if it's hidden in the view display configuration.
 * Also makes CTAs available via EventModeManager.
 */
function myeventlane_event_preprocess_node(array &$variables): void {
  $node = $variables['node'] ?? NULL;
  $view_mode = $variables['view_mode'] ?? 'full';

  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    return;
  }

  if ($view_mode !== 'full') {
    return;
  }

  // Hide default category rendering since we're using colored pills.
  // This is a backup - we also do it in hook_node_view_alter.
  if (isset($variables['content']['field_category'])) {
    unset($variables['content']['field_category']);
  }

  // Ensure event_location_map from myeventlane_location is accessible in content.
  // It's added via hook_node_view to the root build array, move it to content region.
  if (isset($variables['elements']['event_location_map']) && !isset($variables['content']['event_location_map'])) {
    $variables['content']['event_location_map'] = $variables['elements']['event_location_map'];
  }
  if (isset($variables['elements']['event_location_info']) && !isset($variables['content']['event_location_info'])) {
    $variables['content']['event_location_info'] = $variables['elements']['event_location_info'];
  }

  // If field_ticket_types exists on the node but isn't in the content array,
  // add it so the template can render it.
  if ($node->hasField('field_ticket_types') && !$node->get('field_ticket_types')->isEmpty()) {
    if (!isset($variables['content']['field_ticket_types'])) {
      $field_view = $node->get('field_ticket_types')->view('default');
      if (!empty($field_view)) {
        $variables['content']['field_ticket_types'] = $field_view;
      }
    }
  }

  // Ensure accessibility fields are available even if hidden in view display.
  $accessibility_fields = [
    'field_accessibility',
    'field_accessibility_contact',
    'field_accessibility_directions',
    'field_accessibility_entry',
    'field_accessibility_parking',
  ];
  foreach ($accessibility_fields as $field_name) {
    if ($node->hasField($field_name) && !$node->get($field_name)->isEmpty()) {
      if (!isset($variables['content'][$field_name])) {
        $field_view = $node->get($field_name)->view('default');
        if (!empty($field_view)) {
          $variables['content'][$field_name] = $field_view;
        }
      }
    }
  }

  // Add CTAs via EventModeManager service.
  try {
    /** @var \Drupal\myeventlane_event\Service\EventModeManager $mode_manager */
    $mode_manager = \Drupal::service('myeventlane_event.mode_manager');
    $primary_cta = $mode_manager->getPrimaryCta($node);
    $all_ctas = $mode_manager->getAllCtas($node);
    $mode = $mode_manager->getEffectiveMode($node);
    
    $variables['event_cta'] = [
      'primary' => $primary_cta,
      'all' => $all_ctas,
      'mode' => $mode,
    ];
  }
  catch (\Exception $e) {
    // Gracefully fail if service unavailable.
    $variables['event_cta'] = NULL;
  }

  // Add category color classes for styling.
  if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
    try {
      /** @var \Drupal\myeventlane_shared\Service\ColorService $color_service */
      $color_service = \Drupal::service('myeventlane_shared.color_service');
      $categories = [];
      foreach ($node->get('field_category')->referencedEntities() as $term) {
        $category_name = $term->getName();
        $color = $color_service->getColorForTerm($category_name);
        $slug = strtolower($category_name);
        $slug = str_replace([' ', '&'], ['-', 'and'], $slug);
        $slug = preg_replace('/[^a-z0-9-+]/', '', $slug);
        $categories[] = [
          'name' => $category_name,
          'slug' => $slug,
          'color' => $color ?? $color_service->getFallbackColor(),
          'tid' => $term->id(),
        ];
      }
      $variables['event_categories'] = $categories;
    }
    catch (\Exception $e) {
      $variables['event_categories'] = [];
    }
  }
  else {
    $variables['event_categories'] = [];
  }
}

/**
 * Implements hook_entity_presave().
 * Keep any existing presave logic intact if you have it elsewhere.
 */
function myeventlane_event_entity_presave(\Drupal\Core\Entity\EntityInterface $entity): void {
  if (!$entity instanceof NodeInterface) {
    return;
  }
  if ($entity->bundle() !== 'event') {
    return;
  }

  // Intentionally left minimal in this rewrite.
  // Any RSVP/ticket auto-creation should remain in the dedicated custom modules.
}
