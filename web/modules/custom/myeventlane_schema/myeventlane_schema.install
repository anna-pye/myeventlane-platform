<?php

/**
 * @file
 */

declare(strict_types=1);

/**
 * @file
 * Install, update, and uninstall hooks for MyEventLane Schema module.
 *
 * This module owns the creation of all core field storages and field instances
 * that MyEventLane depends on. Fields are primarily created via config/install
 * YAML files, but this file handles any programmatic setup needed.
 */

use Drupal\Component\Serialization\Yaml;

/**
 * Implements hook_install().
 *
 * Performs additional setup after config is imported.
 */
function myeventlane_schema_install(): void {
  // Log successful installation.
  \Drupal::logger('myeventlane_schema')->notice('MyEventLane Schema module installed. Core fields and content types are now available.');

  // Rebuild caches to ensure all field definitions are picked up.
  drupal_flush_all_caches();
}

/**
 * Implements hook_uninstall().
 *
 * Cleans up module-specific data. Note: Field data is NOT deleted by default.
 * Drupal will retain field storage until all bundles using the field are removed.
 */
function myeventlane_schema_uninstall(): void {
  \Drupal::logger('myeventlane_schema')->warning(
    'MyEventLane Schema module uninstalled. Field storages may remain until manually removed. Check /admin/config/development/configuration/single/export for orphaned config.'
  );
}

/**
 * Implements hook_requirements().
 *
 * Reports on the status of the schema module.
 */
function myeventlane_schema_requirements(string $phase): array {
  $requirements = [];

  if ($phase === 'runtime') {
    // Check if the event content type exists.
    $node_type_storage = \Drupal::entityTypeManager()->getStorage('node_type');
    $event_type = $node_type_storage->load('event');

    $requirements['myeventlane_schema_event'] = [
      'title' => t('MyEventLane Event Content Type'),
      'value' => $event_type ? t('Configured') : t('Missing'),
      'severity' => $event_type ? REQUIREMENT_OK : REQUIREMENT_WARNING,
    ];

    if (!$event_type) {
      $requirements['myeventlane_schema_event']['description'] = t('The Event content type is not configured. Run config import or create it manually.');
    }
  }

  return $requirements;
}

/**
 * Creates ticket product type and variation type for Commerce.
 */
function myeventlane_schema_update_9001(): string {
  $entity_type_manager = \Drupal::entityTypeManager();

  // Create ticket variation type.
  $variation_type_storage = $entity_type_manager->getStorage('commerce_product_variation_type');
  if (!$variation_type_storage->load('ticket_variation')) {
    $variation_type = $variation_type_storage->create([
      'id' => 'ticket_variation',
      'label' => 'Ticket Variation',
      'orderItemType' => 'default',
      'generateTitle' => TRUE,
      'traits' => [],
    ]);
    $variation_type->save();
  }

  // Create ticket product type.
  $product_type_storage = $entity_type_manager->getStorage('commerce_product_type');
  if (!$product_type_storage->load('ticket')) {
    $product_type = $product_type_storage->create([
      'id' => 'ticket',
      'label' => 'Event Ticket',
      'description' => 'Ticket product for MyEventLane events (free RSVP or paid)',
      'variationType' => 'ticket_variation',
      'multipleVariations' => TRUE,
      'injectVariationFields' => TRUE,
      'traits' => [],
    ]);
    $product_type->save();
  }

  // Create default store if it doesn't exist.
  $store_storage = $entity_type_manager->getStorage('commerce_store');
  if (!$store_storage->load('default')) {
    $store = $store_storage->create([
      'type' => 'online',
      'uid' => 1,
      'name' => 'MyEventLane Store',
      'mail' => 'noreply@myeventlane.com',
      'default_currency' => 'USD',
      'timezone' => 'America/New_York',
      'address' => [
        'country_code' => 'US',
        'administrative_area' => '',
        'locality' => '',
        'postal_code' => '',
        'address_line1' => '',
        'organization' => 'MyEventLane',
      ],
      'billing_countries' => [],
      'is_default' => TRUE,
    ]);
    $store->save();
  }

  // Now import field configs using config import.
  $config_path = \Drupal::service('extension.list.module')->getPath('myeventlane_schema') . '/config/install';

  // Import field storage for product variation.
  $config_name = 'field.storage.commerce_product_variation.field_event';
  $config_file = $config_path . '/' . $config_name . '.yml';
  if (file_exists($config_file)) {
    $config_data = Yaml::decode(file_get_contents($config_file));
    \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
  }

  // Import field instance for ticket variation.
  $config_name = 'field.field.commerce_product_variation.ticket_variation.field_event';
  $config_file = $config_path . '/' . $config_name . '.yml';
  if (file_exists($config_file)) {
    $config_data = Yaml::decode(file_get_contents($config_file));
    \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
  }

  // Import field instance for ticket product.
  $config_name = 'field.field.commerce_product.ticket.field_event';
  $config_file = $config_path . '/' . $config_name . '.yml';
  if (file_exists($config_file)) {
    $config_data = Yaml::decode(file_get_contents($config_file));
    \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
  }

  drupal_flush_all_caches();

  return 'Created ticket product type, variation type, and default store. Imported field configurations.';
}

/**
 * Creates ticket type fields for event-driven ticket management.
 */
function myeventlane_schema_update_9002(): string {
  $entity_type_manager = \Drupal::entityTypeManager();
  $field_storage_storage = $entity_type_manager->getStorage('field_storage_config');
  $field_config_storage = $entity_type_manager->getStorage('field_config');
  $paragraph_type_storage = $entity_type_manager->getStorage('paragraphs_type');

  // Create paragraph type if it doesn't exist.
  if (!$paragraph_type_storage->load('ticket_type_config')) {
    $paragraph_type = $paragraph_type_storage->create([
      'id' => 'ticket_type_config',
      'label' => 'Ticket Type Configuration',
      'description' => 'Defines a single ticket type (e.g., Full Price, Concession) with price, capacity, and sales window settings.',
    ]);
    $paragraph_type->save();
  }

  // Define field storages to create.
  $field_storages = [
    'paragraph.field_ticket_label_mode' => [
      'field_name' => 'field_ticket_label_mode',
      'entity_type' => 'paragraph',
      'type' => 'list_string',
      'module' => 'options',
      'settings' => [
        'allowed_values' => [
          'preset' => 'Use preset label',
          'custom' => 'Use custom label',
        ],
      ],
    ],
    'paragraph.field_ticket_label_preset' => [
      'field_name' => 'field_ticket_label_preset',
      'entity_type' => 'paragraph',
      'type' => 'list_string',
      'module' => 'options',
      'settings' => [
        'allowed_values' => [
          'full_price' => 'Full Price',
          'concession' => 'Concession',
          'child' => 'Child',
          'member' => 'Member',
          'free' => 'Free',
          'student' => 'Student',
          'senior' => 'Senior',
          'early_bird' => 'Early Bird',
          'vip' => 'VIP',
        ],
      ],
    ],
    'paragraph.field_ticket_label_custom' => [
      'field_name' => 'field_ticket_label_custom',
      'entity_type' => 'paragraph',
      'type' => 'string',
      'module' => 'core',
      'settings' => ['max_length' => 255],
    ],
    'paragraph.field_ticket_price' => [
      'field_name' => 'field_ticket_price',
      'entity_type' => 'paragraph',
      'type' => 'decimal',
      'module' => 'decimal',
      'settings' => ['precision' => 10, 'scale' => 2],
    ],
    'paragraph.field_ticket_capacity' => [
      'field_name' => 'field_ticket_capacity',
      'entity_type' => 'paragraph',
      'type' => 'integer',
      'module' => 'core',
      'settings' => ['unsigned' => TRUE],
    ],
    'paragraph.field_ticket_sales_start' => [
      'field_name' => 'field_ticket_sales_start',
      'entity_type' => 'paragraph',
      'type' => 'datetime',
      'module' => 'datetime',
      'settings' => ['datetime_type' => 'datetime'],
    ],
    'paragraph.field_ticket_sales_end' => [
      'field_name' => 'field_ticket_sales_end',
      'entity_type' => 'paragraph',
      'type' => 'datetime',
      'module' => 'datetime',
      'settings' => ['datetime_type' => 'datetime'],
    ],
    'paragraph.field_ticket_variation_uuid' => [
      'field_name' => 'field_ticket_variation_uuid',
      'entity_type' => 'paragraph',
      'type' => 'string',
      'module' => 'core',
      'settings' => ['max_length' => 36],
    ],
    'node.field_ticket_types' => [
      'field_name' => 'field_ticket_types',
      'entity_type' => 'node',
      'type' => 'entity_reference_revisions',
      'module' => 'entity_reference_revisions',
      'settings' => ['target_type' => 'paragraph'],
    ],
  ];

  // Create field storages.
  foreach ($field_storages as $id => $config) {
    if (!$field_storage_storage->load($id)) {
      $storage = $field_storage_storage->create($config);
      $storage->save();
    }
  }

  // Import field instances from config files.
  $config_path = \Drupal::service('extension.list.module')->getPath('myeventlane_schema') . '/config/install';
  $yaml = Yaml::class;

  // Import paragraph field instances.
  $paragraph_field_files = [
    'field.field.paragraph.ticket_type_config.field_ticket_label_mode',
    'field.field.paragraph.ticket_type_config.field_ticket_label_preset',
    'field.field.paragraph.ticket_type_config.field_ticket_label_custom',
    'field.field.paragraph.ticket_type_config.field_ticket_price',
    'field.field.paragraph.ticket_type_config.field_ticket_capacity',
    'field.field.paragraph.ticket_type_config.field_ticket_sales_start',
    'field.field.paragraph.ticket_type_config.field_ticket_sales_end',
    'field.field.paragraph.ticket_type_config.field_ticket_variation_uuid',
  ];

  foreach ($paragraph_field_files as $config_name) {
    $config_file = $config_path . '/' . $config_name . '.yml';
    if (file_exists($config_file)) {
      $config_data = $yaml::decode(file_get_contents($config_file));
      \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
    }
  }

  // Import node field instance.
  $config_name = 'field.field.node.event.field_ticket_types';
  $config_file = $config_path . '/' . $config_name . '.yml';
  if (file_exists($config_file)) {
    $config_data = $yaml::decode(file_get_contents($config_file));
    \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
  }

  drupal_flush_all_caches();

  return 'Created ticket type paragraph type and all related fields for event-driven ticket management.';
}

/**
 * Add field_event_setup_complete to Event bundle.
 */
function myeventlane_schema_update_9003(): string {
  $entity_type_manager = \Drupal::entityTypeManager();
  $field_storage_storage = $entity_type_manager->getStorage('field_storage_config');
  $field_config_storage = $entity_type_manager->getStorage('field_config');

  // Create field storage if it doesn't exist.
  $storage_id = 'node.field_event_setup_complete';
  if (!$field_storage_storage->load($storage_id)) {
    $storage = $field_storage_storage->create([
      'field_name' => 'field_event_setup_complete',
      'entity_type' => 'node',
      'type' => 'boolean',
      'module' => 'core',
      'settings' => [],
    ]);
    $storage->save();
  }

  // Create field instance if it doesn't exist.
  $field_id = 'node.event.field_event_setup_complete';
  if (!$field_config_storage->load($field_id)) {
    $field = $field_config_storage->create([
      'field_name' => 'field_event_setup_complete',
      'entity_type' => 'node',
      'bundle' => 'event',
      'label' => 'Setup Complete',
      'description' => 'Flag indicating the event was successfully published through the wizard. Used to distinguish wizard drafts from intentionally unpublished events.',
      'required' => FALSE,
      'translatable' => FALSE,
      'default_value' => [
        ['value' => 0],
      ],
      'settings' => [
        'on_label' => 'Setup complete',
        'off_label' => 'Setup incomplete',
      ],
    ]);
    $field->save();
  }

  // Hide field from form displays.
  $form_display_storage = $entity_type_manager->getStorage('entity_form_display');
  $form_display = $form_display_storage->load('node.event.default');
  if ($form_display) {
    $hidden = $form_display->get('hidden');
    $hidden['field_event_setup_complete'] = TRUE;
    $form_display->set('hidden', $hidden);
    $form_display->save();
  }

  drupal_flush_all_caches();

  return 'Created field_event_setup_complete field on Event bundle.';
}

/**
 * Add third_party_settings to entity view display components missing it.
 *
 * Drupal 11 FormatterBase::__construct() requires third_party_settings to be
 * an array. Configs without it cause "Undefined array key third_party_settings"
 * and TypeError when the wizard review step renders field_event_highlights
 * (which loads paragraph.event_highlight.default).
 */
function myeventlane_schema_update_9004(): string {
  $config_factory = \Drupal::configFactory();
  $displays = [
    'core.entity_view_display.paragraph.event_highlight.default',
    'core.entity_view_display.paragraph.attendee_extra_field.default',
    'core.entity_view_display.node.event.teaser',
    'core.entity_view_display.node.event.event_home_card',
  ];

  $updated = 0;
  foreach ($displays as $config_name) {
    $config = $config_factory->getEditable($config_name);
    if ($config->isNew()) {
      continue;
    }

    $content = $config->get('content');
    if (!is_array($content)) {
      continue;
    }

    $changed = FALSE;
    foreach ($content as $field_name => $component) {
      if (!is_array($component)) {
        continue;
      }
      if (!isset($component['third_party_settings'])) {
        $content[$field_name]['third_party_settings'] = [];
        $changed = TRUE;
      }
    }

    if ($changed) {
      $config->set('content', $content)->save(TRUE);
      $updated++;
    }
  }

  if ($updated > 0) {
    drupal_flush_all_caches();
  }

  return sprintf('Added third_party_settings to %d entity view display(s). Fixes FormatterBase TypeError in wizard review.', $updated);
}

/**
 * Add recurring series fields to Event bundle (Option A: Series Template Event).
 *
 * Fields: field_is_series_template, field_series_rrule, field_series_timezone,
 * field_series_parent, field_series_instance_id. All optional; single events
 * unaffected.
 */
function myeventlane_schema_update_9005(): string {
  $entity_type_manager = \Drupal::entityTypeManager();
  $field_storage_storage = $entity_type_manager->getStorage('field_storage_config');
  $field_config_storage = $entity_type_manager->getStorage('field_config');
  $config_path = \Drupal::service('extension.list.module')->getPath('myeventlane_schema') . '/config/install';

  $storages = [
    'field.storage.node.field_is_series_template',
    'field.storage.node.field_series_rrule',
    'field.storage.node.field_series_timezone',
    'field.storage.node.field_series_parent',
    'field.storage.node.field_series_instance_id',
  ];

  foreach ($storages as $config_name) {
    $config_file = $config_path . '/' . $config_name . '.yml';
    if (file_exists($config_file)) {
      $config_data = \Drupal\Component\Serialization\Yaml::decode(file_get_contents($config_file));
      $storage_id = $config_data['id'] ?? str_replace('field.storage.', '', $config_name);
      if (!$field_storage_storage->load($storage_id)) {
        \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
      }
    }
  }

  $fields = [
    'field.field.node.event.field_is_series_template',
    'field.field.node.event.field_series_rrule',
    'field.field.node.event.field_series_timezone',
    'field.field.node.event.field_series_parent',
    'field.field.node.event.field_series_instance_id',
  ];

  foreach ($fields as $config_name) {
    $config_file = $config_path . '/' . $config_name . '.yml';
    if (file_exists($config_file)) {
      $config_data = \Drupal\Component\Serialization\Yaml::decode(file_get_contents($config_file));
      $field_id = $config_data['id'] ?? str_replace('field.field.', '', $config_name);
      if (!$field_config_storage->load($field_id)) {
        \Drupal::configFactory()->getEditable($config_name)->setData($config_data)->save(TRUE);
      }
    }
  }

  // Add series fields to default form display (Recurring series section).
  $form_display_storage = $entity_type_manager->getStorage('entity_form_display');
  $form_display = $form_display_storage->load('node.event.default');
  if ($form_display) {
    $content = $form_display->get('content') ?? [];
    $content['field_is_series_template'] = [
      'type' => 'boolean_checkbox',
      'weight' => 95,
      'region' => 'content',
      'settings' => ['display_label' => TRUE],
      'third_party_settings' => [],
    ];
    $content['field_series_rrule'] = [
      'type' => 'string_textarea',
      'weight' => 96,
      'region' => 'content',
      'settings' => ['rows' => 3, 'placeholder' => ''],
      'third_party_settings' => [],
    ];
    $content['field_series_timezone'] = [
      'type' => 'string_textfield',
      'weight' => 97,
      'region' => 'content',
      'settings' => ['size' => 60, 'placeholder' => ''],
      'third_party_settings' => [],
    ];
    $form_display->set('content', $content);
    $form_display->save();
  }

  drupal_flush_all_caches();

  return 'Added recurring series fields to Event bundle (field_is_series_template, field_series_rrule, field_series_timezone, field_series_parent, field_series_instance_id).';
}

/**
 * Create database tables for recurring series fields.
 *
 * Update 9005 added field config via ConfigFactory, which does not create
 * dedicated field tables. This hook applies entity definition updates to
 * create node__field_is_series_template, node__field_series_*, etc.
 */
function myeventlane_schema_update_9006(): string {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $storage_definitions = $entity_field_manager->getFieldStorageDefinitions('node');

  $series_fields = [
    'field_is_series_template',
    'field_series_rrule',
    'field_series_timezone',
    'field_series_parent',
    'field_series_instance_id',
  ];

  foreach ($series_fields as $field_name) {
    if (!isset($storage_definitions[$field_name])) {
      continue;
    }
    $storage_definition = $storage_definitions[$field_name];
    $original = $entity_definition_update_manager->getFieldStorageDefinition($field_name, 'node');
    if ($original === NULL) {
      $entity_definition_update_manager->installFieldStorageDefinition(
        $field_name,
        'node',
        'myeventlane_schema',
        $storage_definition
      );
    }
  }

  drupal_flush_all_caches();

  return 'Created database tables for recurring series fields (field_is_series_template, field_series_rrule, field_series_timezone, field_series_parent, field_series_instance_id).';
}

/**
 * Ensure event default view display shows body and field_event_intro.
 *
 * The event full page template (node--event--full) expects content.body
 * (About the Event) and content.field_event_intro (What to expect). They
 * only appear when included on the default view display.
 */
function myeventlane_schema_update_9007(): string {
  $storage = \Drupal::entityTypeManager()->getStorage('entity_view_display');
  $display = $storage->load('node.event.default');
  if (!$display) {
    return 'Event default view display not found; nothing to update.';
  }

  $field_exists = static function (string $name): bool {
    return (bool) \Drupal\field\Entity\FieldConfig::loadByName('node', 'event', $name);
  };

  $updated = FALSE;

  if ($field_exists('body') && !$display->getComponent('body')) {
    $display->setComponent('body', [
      'type' => 'text_default',
      'label' => 'hidden',
      'settings' => [],
      'third_party_settings' => [],
      'weight' => 0,
      'region' => 'content',
    ]);
    $updated = TRUE;
  }

  if ($field_exists('field_event_intro') && !$display->getComponent('field_event_intro')) {
    $display->setComponent('field_event_intro', [
      'type' => 'text_default',
      'label' => 'hidden',
      'settings' => [],
      'third_party_settings' => [],
      'weight' => 1,
      'region' => 'content',
    ]);
    $updated = TRUE;
  }

  if ($updated) {
    $display->save();
  }

  return $updated
    ? 'Added body and field_event_intro to event default view display so event description and What to expect render on the event page.'
    : 'Event default view display already had body and field_event_intro.';
}
