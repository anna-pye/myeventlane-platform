<?php

/**
 * @file
 */

declare(strict_types=1);

/**
 * @file
 * Install, update and uninstall functions for the myeventlane_tickets module.
 */

use Drupal\myeventlane_tickets\Entity\Ticket;
use Drupal\Core\Entity\Sql\SqlContentEntityStorage;

/**
 * Implements hook_install().
 */
function myeventlane_tickets_install(): void {
  // Entity schema is created automatically by Drupal based on the Ticket
  // content entity definition. This hook ensures the entity type is properly
  // registered and tables are created.
  \Drupal::logger('myeventlane_tickets')->notice('MyEventLane Tickets module installed. Entity schema created automatically.');
}

/**
 * Ensures the myeventlane_ticket entity tables are created.
 */
function myeventlane_tickets_update_8001(): string {
  $entity_type_manager = \Drupal::entityTypeManager();

  // Get the entity type definition.
  $entity_type = $entity_type_manager->getDefinition('myeventlane_ticket');
  if (!$entity_type) {
    return 'Ticket entity type not found.';
  }

  // Get the storage handler.
  $storage = $entity_type_manager->getStorage('myeventlane_ticket');

  // Check if tables exist by trying to query them.
  $database = \Drupal::database();
  $table_name = $entity_type->getBaseTable();
  $data_table_name = $entity_type->getDataTable();

  $tables_exist = TRUE;
  try {
    $database->query("SELECT 1 FROM {{$table_name}} LIMIT 1")->fetchField();
    if ($data_table_name) {
      $database->query("SELECT 1 FROM {{$data_table_name}} LIMIT 1")->fetchField();
    }
  }
  catch (\Exception $e) {
    $tables_exist = FALSE;
  }

  if (!$tables_exist && $storage instanceof SqlContentEntityStorage) {
    // Force table creation by getting the schema.
    $schema_handler = $storage->getTableMapping();
    // Accessing the storage will trigger table creation on first use.
    // Create a dummy entity to force table creation.
    try {
      $test_entity = $storage->create([]);
      // Don't save it, just creating it should trigger schema creation.
    }
    catch (\Exception $e) {
      // If creation fails, try to manually create tables using the schema.
      $schema = $storage->getSchema();
      $schema->onEntityTypeCreate($entity_type);
    }
  }

  return 'Ticket entity tables created.';
}

/**
 * Properly installs the myeventlane_ticket entity type and tables.
 */
function myeventlane_tickets_update_8002(): string {
  $entity_type_manager = \Drupal::entityTypeManager();
  $update_manager = \Drupal::entityDefinitionUpdateManager();

  // Get the entity type definition.
  $entity_type = $entity_type_manager->getDefinition('myeventlane_ticket', FALSE);
  if (!$entity_type) {
    return 'Ticket entity type not found.';
  }

  // Check if tables exist.
  $database = \Drupal::database();
  $table_name = $entity_type->getBaseTable();

  try {
    $database->query("SELECT 1 FROM {{$table_name}} LIMIT 1")->fetchField();
    return 'Ticket entity tables already exist.';
  }
  catch (\Exception $e) {
    // Tables don't exist, install the entity type.
    try {
      $update_manager->installEntityType($entity_type);
      return 'Ticket entity type and tables installed.';
    }
    catch (\Exception $install_exception) {
      // If installEntityType fails, try installing field storage definitions.
      $field_definitions = Ticket::baseFieldDefinitions($entity_type);
      foreach ($field_definitions as $field_name => $field_definition) {
        try {
          $update_manager->installFieldStorageDefinition($field_name, 'myeventlane_ticket', 'myeventlane_tickets', $field_definition);
        }
        catch (\Exception $field_exception) {
          // Field might already exist, skip.
        }
      }
      return 'Ticket entity field storage definitions installed.';
    }
  }
}

/**
 * Implements hook_schema_alter().
 */
function myeventlane_tickets_schema_alter(array &$schema): void {
  // Ensure ticket_code is unique and indexed.
  if (isset($schema['myeventlane_ticket'])) {
    $schema['myeventlane_ticket']['unique keys']['myeventlane_ticket__ticket_code'] = ['ticket_code'];
    $schema['myeventlane_ticket']['indexes']['myeventlane_ticket__event'] = ['event_id'];
    $schema['myeventlane_ticket']['indexes']['myeventlane_ticket__order'] = ['order_id'];
    $schema['myeventlane_ticket']['indexes']['myeventlane_ticket__order_item'] = ['order_item_id'];
    $schema['myeventlane_ticket']['indexes']['myeventlane_ticket__holder_email'] = ['holder_email'];
  }
}

/**
 * Install new ticketing content entity types added after initial install.
 */
function myeventlane_tickets_update_8003(): string {
  $entity_type_manager = \Drupal::entityTypeManager();
  $update_manager = \Drupal::entityDefinitionUpdateManager();

  $change_list = $update_manager->getChangeList();
  $entity_type_ids = [
    'mel_purchase_surface',
    'mel_event_ticket_settings',
    'mel_ticket_group',
    'mel_access_code',
  ];

  $installed = [];
  foreach ($entity_type_ids as $entity_type_id) {
    if (empty($change_list[$entity_type_id]['entity_type'])) {
      continue;
    }

    $definition = $entity_type_manager->getDefinition($entity_type_id, FALSE);
    if (!$definition) {
      \Drupal::logger('myeventlane_tickets')->error('Could not load entity type definition for @entity_type_id during update 8003.', [
        '@entity_type_id' => $entity_type_id,
      ]);
      throw new \RuntimeException(sprintf('Entity type definition not found: %s', $entity_type_id));
    }

    try {
      $update_manager->installEntityType($definition);
      $installed[] = $entity_type_id;
    }
    catch (\Throwable $e) {
      \Drupal::logger('myeventlane_tickets')->error('Failed to install entity type @entity_type_id during update 8003: @message', [
        '@entity_type_id' => $entity_type_id,
        '@message' => $e->getMessage(),
      ]);
      throw $e;
    }
  }

  if (empty($installed)) {
    return 'No new ticketing entity types required installation.';
  }

  return 'Installed ticketing entity types: ' . implode(', ', $installed) . '.';
}
