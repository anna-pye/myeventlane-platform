<?php

/**
 * @file
 * Install, update, and uninstall functions for myeventlane_vendor module.
 */

/**
 * Implements hook_schema().
 */
function myeventlane_vendor_schema(): array {
  $schema = [];

  // Base table for vendor entities.
  $schema['myeventlane_vendor'] = [
    'description' => 'The base table for vendor entities.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
        'description' => 'Primary Key: Unique vendor ID.',
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'description' => 'The Universally Unique Identifier.',
      ],
      'uid' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'description' => 'The user ID of the vendor owner.',
      ],
      'name' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => 'The vendor name.',
      ],
      'created' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was created.',
      ],
      'changed' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was last changed.',
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'uid' => ['uid'],
      'name' => ['name'],
    ],
  ];

  // Data table for vendor field data.
  $schema['myeventlane_vendor_field_data'] = [
    'description' => 'The data table for vendor entities.',
    'fields' => [
      'id' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'The vendor id this data belongs to.',
      ],
      'langcode' => [
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'description' => 'The language code for this data item.',
      ],
      'uid' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'description' => 'The user ID of the vendor owner.',
      ],
      'name' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => 'The vendor name.',
      ],
      'created' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was created.',
      ],
      'changed' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was last changed.',
      ],
      'default_langcode' => [
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 1,
        'description' => 'A boolean indicating whether this is the default language.',
      ],
    ],
    'primary key' => ['id', 'langcode'],
    'indexes' => [
      'uid' => ['uid'],
      'name' => ['name'],
    ],
  ];

  return $schema;
}

/**
 * Update vendor entity type definition and remove logo field.
 */
function myeventlane_vendor_update_10004() {
  // Uninstall logo field if it exists (check config, not database).
  $field_storage_config_storage = \Drupal::entityTypeManager()->getStorage('field_storage_config');
  $logo_field_storage = $field_storage_config_storage->load('myeventlane_vendor.field_logo_image');
  
  if ($logo_field_storage) {
    try {
      // Delete field instances first.
      $field_config_storage = \Drupal::entityTypeManager()->getStorage('field_config');
      $field_configs = $field_config_storage->loadByProperties([
        'field_name' => 'field_logo_image',
        'entity_type' => 'myeventlane_vendor',
      ]);
      
      foreach ($field_configs as $field_config) {
        $field_config->delete();
      }
      
      // Delete field storage.
      $logo_field_storage->delete();
    }
    catch (\Exception $e) {
      // Field might already be deleted or table doesn't exist - continue.
      \Drupal::logger('myeventlane_vendor')->warning('Could not delete logo field: @message', ['@message' => $e->getMessage()]);
    }
  }
  
  // Also try to delete from config sync if it exists there.
  $config_factory = \Drupal::configFactory();
  try {
    $config_factory->getEditable('field.storage.myeventlane_vendor.field_logo_image')->delete();
    $config_factory->getEditable('field.field.myeventlane_vendor.myeventlane_vendor.field_logo_image')->delete();
  }
  catch (\Exception $e) {
    // Config might not exist - that's fine.
  }
  
  return t('Removed logo field.');
}

/**
 * Update vendor entity type definition (add owner key and fix links).
 */
function myeventlane_vendor_update_10005() {
  // Update the entity type config to match the code definition.
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('core.entity_type.myeventlane_vendor');
  
  // Add owner to entity_keys if missing.
  $entity_keys = $config->get('entity_keys') ?: [];
  if (!isset($entity_keys['owner'])) {
    $entity_keys['owner'] = 'uid';
    $config->set('entity_keys', $entity_keys);
  }
  
  // Update links to match the entity class definition.
  $config->set('links.canonical', '/vendor/{myeventlane_vendor}');
  $config->set('links.collection', '/admin/structure/myeventlane/vendor');
  $config->set('links.add-form', '/admin/structure/myeventlane/vendor/add');
  $config->set('links.edit-form', '/admin/structure/myeventlane/vendor/{myeventlane_vendor}/edit');
  $config->set('links.delete-form', '/admin/structure/myeventlane/vendor/{myeventlane_vendor}/delete');
  
  $config->save();
  
  // Clear entity type cache.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  
  return t('Updated vendor entity type definition.');
}

/**
 * Install api_key_hash base field for vendor entity.
 */
function myeventlane_vendor_update_10006() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');
  $base_field_definitions = \Drupal\myeventlane_vendor\Entity\Vendor::baseFieldDefinitions($entity_type);
  
  // Install api_key_hash field if it doesn't exist.
  if (isset($base_field_definitions['api_key_hash'])) {
    $field_definition = $base_field_definitions['api_key_hash'];
    
    // Check if field storage config exists.
    $field_storage = \Drupal::entityTypeManager()
      ->getStorage('field_storage_config')
      ->load('myeventlane_vendor.api_key_hash');
    
    if (!$field_storage) {
      // Field doesn't exist, install it.
      $entity_definition_update_manager->installFieldStorageDefinition('api_key_hash', 'myeventlane_vendor', 'myeventlane_vendor', $field_definition);
    }
    else {
      // Field exists - check if update is needed via change list.
      $change_list = $entity_definition_update_manager->getChangeList();
      if (isset($change_list['field_storage']['myeventlane_vendor.api_key_hash']) && 
          $change_list['field_storage']['myeventlane_vendor.api_key_hash'] === 'update') {
        // Get the original definition and update.
        try {
          $original = $entity_definition_update_manager->getFieldStorageDefinition('api_key_hash', 'myeventlane_vendor');
          if ($original) {
            $entity_definition_update_manager->updateFieldStorageDefinition($field_definition, $original);
          }
        }
        catch (\Exception $e) {
          \Drupal::logger('myeventlane_vendor')->warning('Could not update api_key_hash field: @message', ['@message' => $e->getMessage()]);
        }
      }
    }
  }
  
  return t('Installed/updated api_key_hash field for vendor entity.');
}

/**
 * Update vendor entity type definition to match code.
 */
function myeventlane_vendor_update_10007() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  
  // Clear caches first to ensure we get the latest definition from code.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();
  
  // Check if entity type updates are needed.
  $change_list = $entity_definition_update_manager->getChangeList();
  
  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    // Get the entity type definition from the code (via the entity type manager).
    $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');
    
    if ($entity_type) {
      // Update the entity type definition.
      $entity_definition_update_manager->updateEntityType($entity_type);
    }
  }
  
  // Clear caches again after update.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  
  return t('Updated vendor entity type definition.');
}

/**
 * Force update vendor entity type definition to match code.
 * 
 * This update hook ensures the entity type definition is properly synced
 * with the code definition, even if previous updates have run.
 */
function myeventlane_vendor_update_10008() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  
  // Clear all caches to ensure we get the latest definition from code.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();
  
  // Check if updates are needed.
  if (!$entity_definition_update_manager->needsUpdates()) {
    return t('No entity definition updates needed.');
  }
  
  // Get the list of changes needed.
  $change_list = $entity_definition_update_manager->getChangeList();
  
  // Apply entity type updates if needed.
  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');
    if ($entity_type) {
      $entity_definition_update_manager->updateEntityType($entity_type);
    }
  }
  
  // Clear caches again after update.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  
  return t('Updated vendor entity type definition.');
}

/**
 * Final update to sync vendor entity type definition.
 * 
 * If EntityDefinitionUpdateManager still shows differences after 10008,
 * this hook will force sync by rebuilding the entity type from code.
 */
function myeventlane_vendor_update_10009() {
  // Clear all caches.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();
  drupal_flush_all_caches();
  
  // Force rebuild entity type definition from code.
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_type = $entity_type_manager->getDefinition('myeventlane_vendor', TRUE);
  
  if (!$entity_type) {
    return t('Could not load vendor entity type definition.');
  }
  
  // Use EntityDefinitionUpdateManager to apply any remaining updates.
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $change_list = $entity_definition_update_manager->getChangeList();
  
  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    $entity_definition_update_manager->updateEntityType($entity_type);
  }
  
  // Clear caches one more time.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  
  return t('Synced vendor entity type definition from code.');
}

/**
 * Implements hook_uninstall().
 */
function myeventlane_vendor_uninstall(): void {
  // Clean up any stale references.
  // The entity system will handle table removal via hook_entity_type_build(),
  // but we ensure config is cleaned up.
  $config_factory = \Drupal::configFactory();

  // Remove entity type config if it exists.
  $config_factory->getEditable('core.entity_type.myeventlane_vendor')->delete();

  // Clear entity type cache.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
}
