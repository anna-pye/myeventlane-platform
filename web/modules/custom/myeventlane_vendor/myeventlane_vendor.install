<?php

/**
 * @file
 * Install, update, and uninstall functions for myeventlane_vendor module.
 */

use Drupal\myeventlane_vendor\Entity\Vendor;

/**
 * Implements hook_schema().
 */
function myeventlane_vendor_schema(): array {
  $schema = [];

  // Base table for vendor entities.
  $schema['myeventlane_vendor'] = [
    'description' => 'The base table for vendor entities.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
        'description' => 'Primary Key: Unique vendor ID.',
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'description' => 'The Universally Unique Identifier.',
      ],
      'uid' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'description' => 'The user ID of the vendor owner.',
      ],
      'name' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => 'The vendor name.',
      ],
      'created' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was created.',
      ],
      'changed' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was last changed.',
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'uid' => ['uid'],
      'name' => ['name'],
    ],
  ];

  // Data table for vendor field data.
  $schema['myeventlane_vendor_field_data'] = [
    'description' => 'The data table for vendor entities.',
    'fields' => [
      'id' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'The vendor id this data belongs to.',
      ],
      'langcode' => [
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'description' => 'The language code for this data item.',
      ],
      'uid' => [
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'description' => 'The user ID of the vendor owner.',
      ],
      'name' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => 'The vendor name.',
      ],
      'created' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was created.',
      ],
      'changed' => [
        'type' => 'int',
        'not null' => FALSE,
        'description' => 'The timestamp when the vendor was last changed.',
      ],
      'default_langcode' => [
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 1,
        'description' => 'A boolean indicating whether this is the default language.',
      ],
    ],
    'primary key' => ['id', 'langcode'],
    'indexes' => [
      'uid' => ['uid'],
      'name' => ['name'],
    ],
  ];

  return $schema;
}

/**
 * Update vendor entity type definition and remove logo field.
 */
function myeventlane_vendor_update_10004() {
  // Uninstall logo field if it exists (check config, not database).
  $field_storage_config_storage = \Drupal::entityTypeManager()->getStorage('field_storage_config');
  $logo_field_storage = $field_storage_config_storage->load('myeventlane_vendor.field_logo_image');

  if ($logo_field_storage) {
    try {
      // Delete field instances first.
      $field_config_storage = \Drupal::entityTypeManager()->getStorage('field_config');
      $field_configs = $field_config_storage->loadByProperties([
        'field_name' => 'field_logo_image',
        'entity_type' => 'myeventlane_vendor',
      ]);

      foreach ($field_configs as $field_config) {
        $field_config->delete();
      }

      // Delete field storage.
      $logo_field_storage->delete();
    }
    catch (\Exception $e) {
      // Field might already be deleted or table doesn't exist - continue.
      \Drupal::logger('myeventlane_vendor')->warning('Could not delete logo field: @message', ['@message' => $e->getMessage()]);
    }
  }

  // Also try to delete from config sync if it exists there.
  $config_factory = \Drupal::configFactory();
  try {
    $config_factory->getEditable('field.storage.myeventlane_vendor.field_logo_image')->delete();
    $config_factory->getEditable('field.field.myeventlane_vendor.myeventlane_vendor.field_logo_image')->delete();
  }
  catch (\Exception $e) {
    // Config might not exist - that's fine.
  }

  return t('Removed logo field.');
}

/**
 * Update vendor entity type definition (add owner key and fix links).
 */
function myeventlane_vendor_update_10005() {
  // Update the entity type config to match the code definition.
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('core.entity_type.myeventlane_vendor');

  // Add owner to entity_keys if missing.
  $entity_keys = $config->get('entity_keys') ?: [];
  if (!isset($entity_keys['owner'])) {
    $entity_keys['owner'] = 'uid';
    $config->set('entity_keys', $entity_keys);
  }

  // Update links to match the entity class definition.
  $config->set('links.canonical', '/vendor/{myeventlane_vendor}');
  $config->set('links.collection', '/admin/structure/myeventlane/vendor');
  $config->set('links.add-form', '/admin/structure/myeventlane/vendor/add');
  $config->set('links.edit-form', '/admin/structure/myeventlane/vendor/{myeventlane_vendor}/edit');
  $config->set('links.delete-form', '/admin/structure/myeventlane/vendor/{myeventlane_vendor}/delete');

  $config->save();

  // Clear entity type cache.
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return t('Updated vendor entity type definition.');
}

/**
 * Install api_key_hash base field for vendor entity.
 */
function myeventlane_vendor_update_10006() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');
  $base_field_definitions = Vendor::baseFieldDefinitions($entity_type);

  // Install api_key_hash field if it doesn't exist.
  if (isset($base_field_definitions['api_key_hash'])) {
    $field_definition = $base_field_definitions['api_key_hash'];

    // Check if field storage config exists.
    $field_storage = \Drupal::entityTypeManager()
      ->getStorage('field_storage_config')
      ->load('myeventlane_vendor.api_key_hash');

    if (!$field_storage) {
      // Field doesn't exist, install it.
      $entity_definition_update_manager->installFieldStorageDefinition('api_key_hash', 'myeventlane_vendor', 'myeventlane_vendor', $field_definition);
    }
    else {
      // Field exists - check if update is needed via change list.
      $change_list = $entity_definition_update_manager->getChangeList();
      if (isset($change_list['field_storage']['myeventlane_vendor.api_key_hash']) &&
          $change_list['field_storage']['myeventlane_vendor.api_key_hash'] === 'update') {
        // Get the original definition and update.
        try {
          $original = $entity_definition_update_manager->getFieldStorageDefinition('api_key_hash', 'myeventlane_vendor');
          if ($original) {
            $entity_definition_update_manager->updateFieldStorageDefinition($field_definition, $original);
          }
        }
        catch (\Exception $e) {
          \Drupal::logger('myeventlane_vendor')->warning('Could not update api_key_hash field: @message', ['@message' => $e->getMessage()]);
        }
      }
    }
  }

  return t('Installed/updated api_key_hash field for vendor entity.');
}

/**
 * Update vendor entity type definition to match code.
 */
function myeventlane_vendor_update_10007() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Clear caches first to ensure we get the latest definition from code.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();

  // Check if entity type updates are needed.
  $change_list = $entity_definition_update_manager->getChangeList();

  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    // Get the entity type definition from the code (via the entity type manager).
    $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');

    if ($entity_type) {
      // Update the entity type definition.
      $entity_definition_update_manager->updateEntityType($entity_type);
    }
  }

  // Clear caches again after update.
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return t('Updated vendor entity type definition.');
}

/**
 * Force update vendor entity type definition to match code.
 *
 * This update hook ensures the entity type definition is properly synced
 * with the code definition, even if previous updates have run.
 */
function myeventlane_vendor_update_10008() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Clear all caches to ensure we get the latest definition from code.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();

  // Check if updates are needed.
  if (!$entity_definition_update_manager->needsUpdates()) {
    return t('No entity definition updates needed.');
  }

  // Get the list of changes needed.
  $change_list = $entity_definition_update_manager->getChangeList();

  // Apply entity type updates if needed.
  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor');
    if ($entity_type) {
      $entity_definition_update_manager->updateEntityType($entity_type);
    }
  }

  // Clear caches again after update.
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return t('Updated vendor entity type definition.');
}

/**
 * Final update to sync vendor entity type definition.
 *
 * If EntityDefinitionUpdateManager still shows differences after 10008,
 * this hook will force sync by rebuilding the entity type from code.
 */
function myeventlane_vendor_update_10009() {
  // Clear all caches.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('cache.discovery')->deleteAll();
  drupal_flush_all_caches();

  // Force rebuild entity type definition from code.
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_type = $entity_type_manager->getDefinition('myeventlane_vendor', TRUE);

  if (!$entity_type) {
    return t('Could not load vendor entity type definition.');
  }

  // Use EntityDefinitionUpdateManager to apply any remaining updates.
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $change_list = $entity_definition_update_manager->getChangeList();

  if (!empty($change_list['entity_type']['myeventlane_vendor'])) {
    $entity_definition_update_manager->updateEntityType($entity_type);
  }

  // Clear caches one more time.
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return t('Synced vendor entity type definition from code.');
}

/**
 * Apply any remaining Vendor entity type definition updates.
 */
function myeventlane_vendor_update_10010(array &$sandbox): string {
  // Ensure we are working with the latest definition from code.
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $change_list = $entity_definition_update_manager->getChangeList();

  if (empty($change_list['myeventlane_vendor']['entity_type'])) {
    return 'No Vendor entity type definition updates required.';
  }

  $entity_type = \Drupal::entityTypeManager()->getDefinition('myeventlane_vendor', FALSE);
  if (!$entity_type) {
    \Drupal::logger('myeventlane_vendor')->error('Could not load Vendor entity type definition during update 10010.');
    throw new \RuntimeException('Vendor entity type definition not found: myeventlane_vendor');
  }

  try {
    // Vendor is a fieldable content entity. Schema updates must run in a batch
    // context (sandbox) or Drupal will reject them.
    $field_storage_definitions = \Drupal::service('entity_field.manager')
      ->getFieldStorageDefinitions('myeventlane_vendor');
    $entity_definition_update_manager->updateFieldableEntityType($entity_type, $field_storage_definitions, $sandbox);
  }
  catch (\Throwable $e) {
    \Drupal::logger('myeventlane_vendor')->error('Failed to update Vendor entity type definition during update 10010: @message', [
      '@message' => $e->getMessage(),
    ]);
    throw $e;
  }

  // Clear cached definitions after applying, when complete.
  if (!empty($sandbox['#finished']) && (float) $sandbox['#finished'] >= 1.0) {
    \Drupal::entityTypeManager()->clearCachedDefinitions();
    return 'Updated Vendor entity type definition via EntityDefinitionUpdateManager.';
  }

  return 'Updating Vendor entity type definition...';
}

/**
 * Install messaging brand and preferences fields on vendor entity.
 */
function myeventlane_vendor_update_10011(): string {
  $field_storage_config_storage = \Drupal::entityTypeManager()->getStorage('field_storage_config');
  $field_config_storage = \Drupal::entityTypeManager()->getStorage('field_config');
  $module_path = \Drupal::service('extension.list.module')->getPath('myeventlane_vendor');

  // List of new fields to install.
  $new_fields = [
    'field_msg_from_name',
    'field_msg_from_email',
    'field_msg_reply_to',
    'field_msg_footer',
    'field_msg_logo',
    'field_msg_accent_color',
    'field_pref_email_on_order',
    'field_pref_email_on_rsvp',
    'field_pref_email_digest',
    'field_social_links',
  ];

  $installed = [];
  $skipped = [];

  foreach ($new_fields as $field_name) {
    $storage_id = "myeventlane_vendor.{$field_name}";

    // Check if field storage already exists.
    $existing_storage = $field_storage_config_storage->load($storage_id);
    if ($existing_storage) {
      $skipped[] = $field_name;
      continue;
    }

    // Load field storage config from YAML.
    $storage_yaml_path = "{$module_path}/config/install/field.storage.myeventlane_vendor.{$field_name}.yml";
    if (!file_exists($storage_yaml_path)) {
      \Drupal::logger('myeventlane_vendor')->warning('Field storage config not found: @path', ['@path' => $storage_yaml_path]);
      continue;
    }

    $storage_config = \Symfony\Component\Yaml\Yaml::parseFile($storage_yaml_path);
    if (!$storage_config) {
      \Drupal::logger('myeventlane_vendor')->warning('Could not parse field storage config: @path', ['@path' => $storage_yaml_path]);
      continue;
    }

    // Create field storage.
    try {
      $field_storage = $field_storage_config_storage->create($storage_config);
      $field_storage->save();
    }
    catch (\Exception $e) {
      \Drupal::logger('myeventlane_vendor')->error('Failed to create field storage @field: @message', [
        '@field' => $field_name,
        '@message' => $e->getMessage(),
      ]);
      continue;
    }

    // Load field instance config from YAML.
    $field_yaml_path = "{$module_path}/config/install/field.field.myeventlane_vendor.myeventlane_vendor.{$field_name}.yml";
    if (!file_exists($field_yaml_path)) {
      \Drupal::logger('myeventlane_vendor')->warning('Field config not found: @path', ['@path' => $field_yaml_path]);
      continue;
    }

    $field_config = \Symfony\Component\Yaml\Yaml::parseFile($field_yaml_path);
    if (!$field_config) {
      \Drupal::logger('myeventlane_vendor')->warning('Could not parse field config: @path', ['@path' => $field_yaml_path]);
      continue;
    }

    // Create field instance.
    try {
      $field = $field_config_storage->create($field_config);
      $field->save();
      $installed[] = $field_name;
    }
    catch (\Exception $e) {
      \Drupal::logger('myeventlane_vendor')->error('Failed to create field instance @field: @message', [
        '@field' => $field_name,
        '@message' => $e->getMessage(),
      ]);
    }
  }

  // Clear entity field caches.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();

  $message = 'Messaging brand and preferences fields update complete.';
  if (!empty($installed)) {
    $message .= ' Installed: ' . implode(', ', $installed) . '.';
  }
  if (!empty($skipped)) {
    $message .= ' Skipped (already exist): ' . implode(', ', $skipped) . '.';
  }

  return $message;
}

/**
 * Ensure list_string fields (accent_color, email_digest) exist with correct allowed_values.
 *
 * This hook uses FieldStorageConfig/FieldConfig APIs directly (no YAML parsing)
 * to guarantee these fields exist on a fresh database after running updb.
 *
 * Also installs new business fields: field_abn and field_business_name.
 */
function myeventlane_vendor_update_10012(): string {
  $messages = [];

  // Define fields in PHP - no YAML parsing at runtime.
  $fields = [
    'field_msg_accent_color' => [
      'storage' => [
        'field_name' => 'field_msg_accent_color',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'list_string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'allowed_values' => [
            '#f26d5b' => 'Coral (MEL Primary)',
            '#6e7ef2' => 'Lavender',
            '#4f9da6' => 'Teal',
            '#5b8c5a' => 'Forest',
            '#e8a838' => 'Amber',
            '#8b5cf6' => 'Violet',
            '#293241' => 'Charcoal',
          ],
          'allowed_values_function' => '',
        ],
      ],
      'field' => [
        'field_name' => 'field_msg_accent_color',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'Messaging Accent Colour',
        'description' => 'Accent colour for buttons and links in outgoing emails.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [['value' => '#f26d5b']],
      ],
    ],
    'field_pref_email_digest' => [
      'storage' => [
        'field_name' => 'field_pref_email_digest',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'list_string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'allowed_values' => [
            'never' => 'Never',
            'daily' => 'Daily',
            'weekly' => 'Weekly',
          ],
          'allowed_values_function' => '',
        ],
      ],
      'field' => [
        'field_name' => 'field_pref_email_digest',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'Email Digest Frequency',
        'description' => 'How often to receive digest emails with activity summaries.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [['value' => 'daily']],
      ],
    ],
    'field_abn' => [
      'storage' => [
        'field_name' => 'field_abn',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'max_length' => 14,
          'is_ascii' => TRUE,
          'case_sensitive' => FALSE,
        ],
      ],
      'field' => [
        'field_name' => 'field_abn',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'ABN',
        'description' => 'Australian Business Number for invoicing and tax purposes.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [],
      ],
    ],
    'field_business_name' => [
      'storage' => [
        'field_name' => 'field_business_name',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'max_length' => 255,
          'is_ascii' => FALSE,
          'case_sensitive' => FALSE,
        ],
      ],
      'field' => [
        'field_name' => 'field_business_name',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'Legal Business Name',
        'description' => 'Your registered business name for invoices and legal documents.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [],
      ],
    ],
  ];

  foreach ($fields as $field_name => $config) {
    // Check if field storage exists.
    $storage = \Drupal\field\Entity\FieldStorageConfig::loadByName('myeventlane_vendor', $field_name);

    if (!$storage) {
      // Create field storage.
      try {
        $storage = \Drupal\field\Entity\FieldStorageConfig::create($config['storage']);
        $storage->save();
        $messages[] = "Created field storage: {$field_name}";
      }
      catch (\Exception $e) {
        \Drupal::logger('myeventlane_vendor')->error('Failed to create field storage @field: @message', [
          '@field' => $field_name,
          '@message' => $e->getMessage(),
        ]);
        $messages[] = "ERROR creating storage for {$field_name}: " . $e->getMessage();
        continue;
      }
    }
    else {
      // Storage exists - verify allowed_values are correct.
      $current_settings = $storage->getSettings();
      $expected_values = $config['storage']['settings']['allowed_values'];

      if ($current_settings['allowed_values'] !== $expected_values) {
        $storage->setSetting('allowed_values', $expected_values);
        $storage->save();
        $messages[] = "Updated allowed_values for: {$field_name}";
      }
      else {
        $messages[] = "Field storage already correct: {$field_name}";
      }
    }

    // Check if field instance exists.
    $field = \Drupal\field\Entity\FieldConfig::loadByName('myeventlane_vendor', 'myeventlane_vendor', $field_name);

    if (!$field) {
      // Create field instance.
      try {
        $field = \Drupal\field\Entity\FieldConfig::create($config['field']);
        $field->save();
        $messages[] = "Created field instance: {$field_name}";
      }
      catch (\Exception $e) {
        \Drupal::logger('myeventlane_vendor')->error('Failed to create field instance @field: @message', [
          '@field' => $field_name,
          '@message' => $e->getMessage(),
        ]);
        $messages[] = "ERROR creating instance for {$field_name}: " . $e->getMessage();
      }
    }
    else {
      $messages[] = "Field instance already exists: {$field_name}";
    }
  }

  // Clear cached field definitions.
  \Drupal::service('entity.definition_update_manager')->getChangeList();
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return implode(' | ', $messages);
}

/**
 * Install business information fields (ABN and Legal Business Name).
 */
function myeventlane_vendor_update_10013(): string {
  $messages = [];

  $fields = [
    'field_abn' => [
      'storage' => [
        'field_name' => 'field_abn',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'max_length' => 14,
          'is_ascii' => TRUE,
          'case_sensitive' => FALSE,
        ],
      ],
      'field' => [
        'field_name' => 'field_abn',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'ABN',
        'description' => 'Australian Business Number for invoicing and tax purposes.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [],
      ],
    ],
    'field_business_name' => [
      'storage' => [
        'field_name' => 'field_business_name',
        'entity_type' => 'myeventlane_vendor',
        'type' => 'string',
        'cardinality' => 1,
        'translatable' => FALSE,
        'settings' => [
          'max_length' => 255,
          'is_ascii' => FALSE,
          'case_sensitive' => FALSE,
        ],
      ],
      'field' => [
        'field_name' => 'field_business_name',
        'entity_type' => 'myeventlane_vendor',
        'bundle' => 'myeventlane_vendor',
        'label' => 'Legal Business Name',
        'description' => 'Your registered business name for invoices and legal documents.',
        'required' => FALSE,
        'translatable' => FALSE,
        'default_value' => [],
      ],
    ],
  ];

  foreach ($fields as $field_name => $config) {
    $storage = \Drupal\field\Entity\FieldStorageConfig::loadByName('myeventlane_vendor', $field_name);

    if (!$storage) {
      try {
        $storage = \Drupal\field\Entity\FieldStorageConfig::create($config['storage']);
        $storage->save();
        $messages[] = "Created storage: {$field_name}";
      }
      catch (\Exception $e) {
        \Drupal::logger('myeventlane_vendor')->error('Failed to create field storage @field: @message', [
          '@field' => $field_name,
          '@message' => $e->getMessage(),
        ]);
        $messages[] = "ERROR storage {$field_name}: " . $e->getMessage();
        continue;
      }
    }
    else {
      $messages[] = "Storage exists: {$field_name}";
    }

    $field = \Drupal\field\Entity\FieldConfig::loadByName('myeventlane_vendor', 'myeventlane_vendor', $field_name);

    if (!$field) {
      try {
        $field = \Drupal\field\Entity\FieldConfig::create($config['field']);
        $field->save();
        $messages[] = "Created instance: {$field_name}";
      }
      catch (\Exception $e) {
        \Drupal::logger('myeventlane_vendor')->error('Failed to create field instance @field: @message', [
          '@field' => $field_name,
          '@message' => $e->getMessage(),
        ]);
        $messages[] = "ERROR instance {$field_name}: " . $e->getMessage();
      }
    }
    else {
      $messages[] = "Instance exists: {$field_name}";
    }
  }

  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
  \Drupal::entityTypeManager()->clearCachedDefinitions();

  return implode(' | ', $messages);
}

/**
 * Implements hook_uninstall().
 */
function myeventlane_vendor_uninstall(): void {
  // Clean up any stale references.
  // The entity system will handle table removal via hook_entity_type_build(),
  // but we ensure config is cleaned up.
  $config_factory = \Drupal::configFactory();

  // Remove entity type config if it exists.
  $config_factory->getEditable('core.entity_type.myeventlane_vendor')->delete();

  // Clear entity type cache.
  \Drupal::entityTypeManager()->clearCachedDefinitions();
}
