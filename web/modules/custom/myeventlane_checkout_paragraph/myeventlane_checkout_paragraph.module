<?php

/**
 * @file
 * Module hooks for MyEventLane Checkout Paragraph.
 */

declare(strict_types=1);

use Drupal\commerce_order\Entity\OrderItemInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\paragraphs\ParagraphInterface;

/**
 * Implements hook_entity_access().
 *
 * Enforces access control for attendee_answer paragraphs.
 */
function myeventlane_checkout_paragraph_entity_access(EntityInterface $entity, string $operation, AccountInterface $account): AccessResult {
  // Only handle attendee_answer paragraphs.
  if (!$entity instanceof ParagraphInterface || $entity->bundle() !== 'attendee_answer') {
    return AccessResult::neutral();
  }

  // Admin users always have access.
  if ($account->hasPermission('administer commerce_order') || $account->hasPermission('bypass node access')) {
    return AccessResult::allowed()->cachePerPermissions();
  }

  // Anonymous users are denied.
  if ($account->isAnonymous()) {
    return AccessResult::forbidden()->cachePerPermissions();
  }

  // Resolve paragraph relationships.
  $access_resolver = \Drupal::service('myeventlane_checkout_paragraph.access_resolver');
  $order = $access_resolver->getParentOrder($entity);
  if (!$order) {
    // If we can't resolve the order, deny access (safety first).
    \Drupal::logger('myeventlane_checkout')->error(
      'Access denied: attendee_answer paragraph @pid has no resolvable parent order.',
      [
        '@pid' => $entity->id(),
        'order_id' => NULL,
        'event_id' => NULL,
        'user_id' => (int) $account->id(),
        'operation' => $operation,
      ]
    );
    return AccessResult::forbidden()->addCacheableDependency($entity);
  }

  // Check customer access: user must own the order.
  $customer_id = (int) ($order->getCustomerId() ?? 0);
  $is_customer = $customer_id === (int) $account->id() && $customer_id > 0;

  // Check vendor access: vendor must own the event.
  $is_vendor = FALSE;
  $event = $access_resolver->getEvent($entity);
  $event_id = $event ? (int) $event->id() : NULL;
  if ($event) {
    $vendor_resolver = \Drupal::service('myeventlane_checkout_flow.vendor_ownership_resolver');
    $store = $vendor_resolver->getStoreForUser($account);
    if ($store) {
      $is_vendor = $vendor_resolver->vendorOwnsEvent($store, $event);
    }
  }

  $order_id = (int) $order->id();

  // Determine access based on operation.
  switch ($operation) {
    case 'view':
      // Customers and vendors can view attendee data.
      if ($is_customer || $is_vendor) {
        return AccessResult::allowed()
          ->cachePerUser()
          ->addCacheableDependency($entity)
          ->addCacheableDependency($order);
      }
      \Drupal::logger('myeventlane_checkout')->warning(
        'Access denied: attendee_answer paragraph @pid view not permitted for user @uid.',
        [
          '@pid' => $entity->id(),
          '@uid' => (int) $account->id(),
          'order_id' => $order_id,
          'event_id' => $event_id,
          'user_id' => (int) $account->id(),
          'operation' => $operation,
        ]
      );
      return AccessResult::forbidden()
        ->cachePerUser()
        ->addCacheableDependency($entity)
        ->addCacheableDependency($order);

    case 'update':
    case 'delete':
      // Check if order is locked (placed or later).
      if ($access_resolver->isOrderLocked($order)) {
        // Order is locked - deny update/delete for everyone except admin.
        \Drupal::logger('myeventlane_checkout')->warning(
          'Access denied: attendee_answer paragraph @pid @op blocked because order @order_id is locked.',
          [
            '@pid' => $entity->id(),
            '@op' => $operation,
            '@order_id' => $order_id,
            'order_id' => $order_id,
            'event_id' => $event_id,
            'user_id' => (int) $account->id(),
            'operation' => $operation,
          ]
        );
        return AccessResult::forbidden('Attendee data cannot be modified after order placement.')
          ->cachePerUser()
          ->addCacheableDependency($entity)
          ->addCacheableDependency($order);
      }

      // For unlocked orders, only customers can update/delete their own data.
      if ($is_customer) {
        return AccessResult::allowed()
          ->cachePerUser()
          ->addCacheableDependency($entity)
          ->addCacheableDependency($order);
      }

      // Vendors cannot update/delete attendee data (even for their events).
      \Drupal::logger('myeventlane_checkout')->warning(
        'Access denied: attendee_answer paragraph @pid @op not permitted for user @uid.',
        [
          '@pid' => $entity->id(),
          '@op' => $operation,
          '@uid' => (int) $account->id(),
          'order_id' => $order_id,
          'event_id' => $event_id,
          'user_id' => (int) $account->id(),
          'operation' => $operation,
        ]
      );
      return AccessResult::forbidden('Vendors cannot modify attendee data.')
        ->cachePerUser()
        ->addCacheableDependency($entity)
        ->addCacheableDependency($order);

    default:
      return AccessResult::neutral()->cachePerPermissions();
  }
}

/**
 * Implements hook_entity_delete().
 */
function myeventlane_checkout_paragraph_entity_delete(EntityInterface $entity): void {
  // Cascade delete attendee paragraphs when order item is deleted.
  if ($entity instanceof OrderItemInterface) {
    if ($entity->hasField('field_ticket_holder') && !$entity->get('field_ticket_holder')->isEmpty()) {
      $paragraphs = $entity->get('field_ticket_holder')->referencedEntities();
      foreach ($paragraphs as $paragraph) {
        if ($paragraph instanceof ParagraphInterface) {
          // Delete nested question paragraphs first.
          if ($paragraph->hasField('field_attendee_questions') && !$paragraph->get('field_attendee_questions')->isEmpty()) {
            $question_paragraphs = $paragraph->get('field_attendee_questions')->referencedEntities();
            foreach ($question_paragraphs as $question_para) {
              $question_para->delete();
            }
          }
          // Delete the attendee paragraph.
          $paragraph->delete();
        }
      }
    }
  }
}

/**
 * Implements hook_paragraph_presave().
 */
function myeventlane_checkout_paragraph_paragraph_presave(ParagraphInterface $paragraph): void {
  // Integrity check: ensure attendee_answer paragraphs have a parent order item.
  if ($paragraph->bundle() === 'attendee_answer') {
    // Check if this paragraph is referenced by any order item.
    $order_item_storage = \Drupal::entityTypeManager()->getStorage('commerce_order_item');
    $query = $order_item_storage->getQuery()
      ->accessCheck(FALSE)
      ->condition('field_ticket_holder', $paragraph->id())
      ->range(0, 1)
      ->execute();

    if (empty($query)) {
      // Paragraph is being saved without a parent order item reference.
      // This could be legitimate during creation, but log a warning if it's not new.
      if (!$paragraph->isNew()) {
        \Drupal::logger('myeventlane_checkout')->warning(
          'Integrity check: attendee_answer paragraph @pid is being saved but is not referenced by any order item via field_ticket_holder.',
          ['@pid' => $paragraph->id()]
        );
      }
    }
  }
}
