<?php

/**
 * @file
 * Hook implementations for myeventlane_location module.
 *
 * Provides address autocomplete with Google Maps and Apple Maps support,
 * and embedded map rendering on Event pages.
 */

declare(strict_types=1);

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;

/**
 * Implements hook_theme().
 */
function myeventlane_location_theme(): array {
  return [
    'event_location_map' => [
      'variables' => [
        'event' => NULL,
        'latitude' => NULL,
        'longitude' => NULL,
        'address' => NULL,
        'venue_name' => NULL,
        'provider' => NULL,
      ],
      'template' => 'event-location-map',
    ],
    'event_location_info' => [
      'variables' => [
        'event' => NULL,
        'address' => NULL,
        'venue_name' => NULL,
      ],
      'template' => 'event-location-info',
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for node_event_form.
 */
function myeventlane_location_form_node_event_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
  _myeventlane_location_hide_unused_address_fields($form);
}

/**
 * Implements hook_form_FORM_ID_alter() for node_event_edit_form.
 */
function myeventlane_location_form_node_event_edit_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
  _myeventlane_location_hide_unused_address_fields($form);
}

/**
 * Implements hook_form_FORM_ID_alter() for vendor_event_create_form.
 */
function myeventlane_location_form_vendor_event_create_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
  _myeventlane_location_hide_unused_address_fields($form);
}

/**
 * Implements hook_form_FORM_ID_alter() for event_wizard_when_where_form.
 *
 * Ensures address lookup (autocomplete) and Australia default apply to the
 * wizard When & Where step.
 */
function myeventlane_location_form_event_wizard_when_where_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
  _myeventlane_location_hide_unused_address_fields($form);
}

/**
 * Alters the event node form to add address autocomplete widget.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _myeventlane_location_alter_event_form(array &$form, FormStateInterface $form_state): void {
  // CRITICAL: Always attach drupalSettings for JavaScript, even if field_location doesn't exist yet.
  // This must happen before any early returns.
  // Get provider settings for JavaScript.
  /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
  $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
  $settings = $provider_manager->getFrontendSettings();

  // For Apple Maps, we need to generate a token server-side.
  if ($settings['provider'] === 'apple_maps') {
    /** @var \Drupal\myeventlane_location\Service\MapKitTokenGenerator $token_generator */
    $token_generator = \Drupal::service('myeventlane_location.mapkit_token_generator');
    $token = $token_generator->generateToken();
    if (!empty($token)) {
      $settings['apple_maps_token'] = $token;
    }
  }

  // Attach drupalSettings - this is critical for the JavaScript to work.
  // Merge with existing settings if any (from widget or other modules).
  if (!isset($form['#attached']['drupalSettings'])) {
    $form['#attached']['drupalSettings'] = [];
  }
  if (!isset($form['#attached']['drupalSettings']['myeventlaneLocation'])) {
    $form['#attached']['drupalSettings']['myeventlaneLocation'] = [];
  }
  // Merge settings to preserve any existing values (like Apple Maps token from widget).
  $form['#attached']['drupalSettings']['myeventlaneLocation'] = array_merge(
    $form['#attached']['drupalSettings']['myeventlaneLocation'],
    $settings
  );

  // Find field_location wherever it exists in the form (might be at root or moved to wizard).
  // Check root first (normal form).
  $field_location_ref = NULL;
  $is_wizard_form = FALSE;

  // Check if this is the wizard form (EventWizardForm).
  if (isset($form['#form_id']) && $form['#form_id'] === 'myeventlane_event_wizard') {
    $is_wizard_form = TRUE;
  }
  elseif (isset($form['wizard']) || isset($form['wizard_step'])) {
    $is_wizard_form = TRUE;
  }

  if (isset($form['field_location'])) {
    $field_location_ref = &$form['field_location'];
  }
  // Check wizard structure with venue wrapper (EventWizardForm - when_where step).
  elseif (isset($form['wizard']['content']['_venue_wrapper']['field_location'])) {
    $field_location_ref = &$form['wizard']['content']['_venue_wrapper']['field_location'];
  }
  // Check wizard structure with location wrapper (EventWizardForm - when_where step).
  elseif (isset($form['wizard']['content']['_location_wrapper']['field_location'])) {
    $field_location_ref = &$form['wizard']['content']['_location_wrapper']['field_location'];
  }
  // Check new wizard structure (EventWizardForm - other steps).
  elseif (isset($form['wizard']['content']['field_location'])) {
    $field_location_ref = &$form['wizard']['content']['field_location'];
  }
  // Check new wizard structure (EventWizardForm - alternative path).
  elseif (isset($form['wizard']['content']['step_content']['location_fields']['field_location'])) {
    $field_location_ref = &$form['wizard']['content']['step_content']['location_fields']['field_location'];
  }
  // Check old wizard structure (EventFormAlter).
  elseif (isset($form['mel_wizard']['layout']['content'])) {
    foreach ($form['mel_wizard']['layout']['content'] as $step_key => &$step_content) {
      if (is_array($step_content) && isset($step_content['section']['field_location'])) {
        $field_location_ref = &$step_content['section']['field_location'];
        break;
      }
    }
  }

  // For wizard forms, if field_location is hidden (by EventWizardForm), don't add search field to it.
  if ($is_wizard_form && isset($field_location_ref) && isset($field_location_ref['#access']) && $field_location_ref['#access'] === FALSE) {
    // Field is intentionally hidden in wizard - just attach library for the custom search field.
    $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';
    return;
  }

  if (!$field_location_ref) {
    // Still attach library even if field doesn't exist (might be added later).
    $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';
    return;
  }

  // Ensure the widget has the wrapper class.
  if (!isset($field_location_ref['#attributes'])) {
    $field_location_ref['#attributes'] = [];
  }
  if (!isset($field_location_ref['#attributes']['class'])) {
    $field_location_ref['#attributes']['class'] = [];
  }
  if (!in_array('myeventlane-location-address-widget', $field_location_ref['#attributes']['class'])) {
    $field_location_ref['#attributes']['class'][] = 'myeventlane-location-address-widget';
  }

  // Add the address search field if it doesn't exist (in case widget isn't using AddressAutocompleteWidget).
  // Check if address_search already exists in any widget delta.
  $has_search_field = FALSE;
  if (isset($field_location_ref['widget']) && is_array($field_location_ref['widget'])) {
    foreach ($field_location_ref['widget'] as $delta => $widget_element) {
      if (is_numeric($delta) && isset($widget_element['address_search'])) {
        $has_search_field = TRUE;
        break;
      }
    }
  }

  // If no search field exists, add it to the first widget delta (delta 0).
  // BUT: Skip this for wizard forms - they have their own search field.
  if (!$has_search_field && isset($field_location_ref['widget'][0]) && !$is_wizard_form) {
    $field_location_ref['widget'][0]['address_search'] = [
      '#type' => 'textfield',
      '#title' => t('Search for address or venue'),
      '#description' => t('Start typing to search for an address. Select from the suggestions to populate the address fields.'),
      '#attributes' => [
        'class' => ['myeventlane-location-address-search'],
        'autocomplete' => 'off',
        'placeholder' => t('Type address or venue name...'),
      ],
      '#weight' => -10,
    ];

    // Add hidden latitude/longitude fields if they don't exist.
    if (!isset($field_location_ref['widget'][0]['latitude'])) {
      $field_location_ref['widget'][0]['latitude'] = [
        '#type' => 'hidden',
        '#attributes' => [
          'class' => ['myeventlane-location-latitude'],
        ],
      ];
    }

    if (!isset($field_location_ref['widget'][0]['longitude'])) {
      $field_location_ref['widget'][0]['longitude'] = [
        '#type' => 'hidden',
        '#attributes' => [
          'class' => ['myeventlane-location-longitude'],
        ],
      ];
    }

    // Add map preview container.
    if (!isset($field_location_ref['widget'][0]['map_preview'])) {
      $field_location_ref['widget'][0]['map_preview'] = [
        '#type' => 'container',
        '#attributes' => [
          'class' => ['myeventlane-location-map-preview'],
          'style' => 'width: 100%; height: 200px; margin-top: 1em; border: 1px solid #ccc; display: none;',
        ],
        '#weight' => 100,
      ];
    }

    // Set default country to Australia if address field exists.
    if (isset($field_location_ref['widget'][0]['address'])) {
      if (isset($field_location_ref['widget'][0]['address']['country_code'])) {
        $country_element = &$field_location_ref['widget'][0]['address']['country_code'];
        if (isset($country_element['#options']) && isset($country_element['#options']['AU'])) {
          // Set default value to AU if not already set.
          if (!isset($country_element['#default_value']) || empty($country_element['#default_value'])) {
            $country_element['#default_value'] = 'AU';
          }
        }
      }
    }
  }

  // Update field_location title to be more descriptive.
  if (isset($field_location_ref['#title']) && $field_location_ref['#title'] === 'Location') {
    $field_location_ref['#title'] = t('Address Details');
    if (!isset($field_location_ref['#description'])) {
      $field_location_ref['#description'] = t('Use the search field above to find and select an address. The address fields below will be automatically filled.');
    }
  }

  // Hide the coordinate fields from the form display if they're showing up.
  // We'll use hidden form elements instead that are populated by JavaScript.
  $form_object = $form_state->getFormObject();
  $node = method_exists($form_object, 'getEntity')
    ? $form_object->getEntity()
    : (method_exists($form_object, 'getEvent') ? $form_object->getEvent() : NULL);
  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';
    return;
  }

  // Hide and bypass validation for coordinate fields - they're auto-populated by JS.
  // Empty values would otherwise trigger "Latitude/Longitude is not a valid number".
  _myeventlane_location_bypass_coordinate_validation($form);

  // Add our own hidden fields for coordinates (these will be populated by JavaScript).
  // These are separate from the actual entity fields to avoid validation issues.
  if ($node->hasField('field_location_latitude')) {
    $form['myeventlane_location_latitude'] = [
      '#type' => 'hidden',
      '#attributes' => [
        'class' => ['myeventlane-location-latitude-field'],
      ],
      '#default_value' => !$node->get('field_location_latitude')->isEmpty()
        ? (string) $node->get('field_location_latitude')->value
        : '',
    ];
  }

  if ($node->hasField('field_location_longitude')) {
    $form['myeventlane_location_longitude'] = [
      '#type' => 'hidden',
      '#attributes' => [
        'class' => ['myeventlane-location-longitude-field'],
      ],
      '#default_value' => !$node->get('field_location_longitude')->isEmpty()
        ? (string) $node->get('field_location_longitude')->value
        : '',
    ];
  }

  // The wrapper already has the class for JavaScript targeting.
  // Attach our library for autocomplete functionality.
  $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';

  // Note: drupalSettings are already attached at the top of this function
  // to ensure they're always available, even if field_location doesn't exist.
  // Add submit handler to save coordinates.
  if (isset($form['actions']['submit'])) {
    $form['actions']['submit']['#submit'][] = '_myeventlane_location_save_coordinates';
  }
}

/**
 * Recursively finds and bypasses validation for coordinate fields.
 *
 * Prevents "Latitude/Longitude is not a valid number" when fields are empty
 * (auto-populated by address autocomplete JS).
 *
 * @param array $elements
 *   Form elements to process (passed by reference).
 */
function _myeventlane_location_bypass_coordinate_validation(array &$elements): void {
  $coordinate_fields = ['field_location_latitude', 'field_location_longitude'];
  foreach ($coordinate_fields as $field_name) {
    if (isset($elements[$field_name]) && is_array($elements[$field_name])) {
      $elements[$field_name]['#access'] = FALSE;
      $elements[$field_name]['#required'] = FALSE;
      $elements[$field_name]['#validated'] = TRUE;
      if (isset($elements[$field_name]['widget']) && is_array($elements[$field_name]['widget'])) {
        foreach ($elements[$field_name]['widget'] as $delta => &$widget_element) {
          if (is_numeric($delta) && is_array($widget_element)) {
            $widget_element['#access'] = FALSE;
            $widget_element['#required'] = FALSE;
            $widget_element['#validated'] = TRUE;
            if (isset($widget_element['value'])) {
              $widget_element['value']['#access'] = FALSE;
              $widget_element['value']['#required'] = FALSE;
              $widget_element['value']['#validated'] = TRUE;
            }
          }
        }
      }
    }
  }
  foreach ($elements as $key => &$child) {
    if (is_array($child) && !str_starts_with((string) $key, '#')) {
      _myeventlane_location_bypass_coordinate_validation($child);
    }
  }
}

/**
 * Form submit handler to save latitude and longitude from address widget.
 */
function _myeventlane_location_save_coordinates(array &$form, FormStateInterface $form_state): void {
  $form_object = $form_state->getFormObject();
  $node = method_exists($form_object, 'getEntity')
    ? $form_object->getEntity()
    : (method_exists($form_object, 'getEvent') ? $form_object->getEvent() : NULL);
  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    return;
  }

  $lat = NULL;
  $lng = NULL;

  // Get coordinates from our hidden fields added by form_alter.
  // We use custom field names to avoid validation issues with the actual entity fields.
  $user_input = $form_state->getUserInput();

  // Check our custom hidden fields first (from form submission).
  if (isset($user_input['myeventlane_location_latitude']) && !empty($user_input['myeventlane_location_latitude']) && is_numeric($user_input['myeventlane_location_latitude'])) {
    $lat = (float) $user_input['myeventlane_location_latitude'];
  }
  elseif ($form_state->hasValue('myeventlane_location_latitude')) {
    $lat_value = $form_state->getValue('myeventlane_location_latitude');
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if (isset($user_input['myeventlane_location_longitude']) && !empty($user_input['myeventlane_location_longitude']) && is_numeric($user_input['myeventlane_location_longitude'])) {
    $lng = (float) $user_input['myeventlane_location_longitude'];
  }
  elseif ($form_state->hasValue('myeventlane_location_longitude')) {
    $lng_value = $form_state->getValue('myeventlane_location_longitude');
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }

  // Also check the actual entity fields in case they were set directly.
  if ($lat === NULL && isset($user_input['field_location_latitude']) && !empty($user_input['field_location_latitude']) && is_numeric($user_input['field_location_latitude'])) {
    $lat = (float) $user_input['field_location_latitude'];
  }
  if ($lng === NULL && isset($user_input['field_location_longitude']) && !empty($user_input['field_location_longitude']) && is_numeric($user_input['field_location_longitude'])) {
    $lng = (float) $user_input['field_location_longitude'];
  }

  // Step form: inner widget has #parents = ['field_location'], so lat/lng
  // are at field_location[0][latitude] / field_location[0][longitude].
  if ($lat === NULL && $form_state->hasValue(['field_location', 0, 'latitude'])) {
    $lat_value = $form_state->getValue(['field_location', 0, 'latitude']);
    if ($lat_value !== NULL && $lat_value !== '' && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }
  if ($lng === NULL && $form_state->hasValue(['field_location', 0, 'longitude'])) {
    $lng_value = $form_state->getValue(['field_location', 0, 'longitude']);
    if ($lng_value !== NULL && $lng_value !== '' && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }
  if ($lat === NULL && isset($user_input['field_location'][0]['latitude']) && is_numeric($user_input['field_location'][0]['latitude'])) {
    $lat = (float) $user_input['field_location'][0]['latitude'];
  }
  if ($lng === NULL && isset($user_input['field_location'][0]['longitude']) && is_numeric($user_input['field_location'][0]['longitude'])) {
    $lng = (float) $user_input['field_location'][0]['longitude'];
  }

  // Check for dedicated coordinate fields (field_location_latitude/longitude or field_event_lat/lng).
  if ($lat === NULL && $form_state->hasValue(['field_location_latitude', 0, 'value'])) {
    $lat_value = $form_state->getValue(['field_location_latitude', 0, 'value']);
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if ($lng === NULL && $form_state->hasValue(['field_location_longitude', 0, 'value'])) {
    $lng_value = $form_state->getValue(['field_location_longitude', 0, 'value']);
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }

  // Check for legacy field_event_lat/lng fields.
  if ($lat === NULL && $form_state->hasValue(['field_event_lat', 0, 'value'])) {
    $lat_value = $form_state->getValue(['field_event_lat', 0, 'value']);
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if ($lng === NULL && $form_state->hasValue(['field_event_lng', 0, 'value'])) {
    $lng_value = $form_state->getValue(['field_event_lng', 0, 'value']);
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }

  // Step form (event_wizard_when_where_form): field_location has #parents
  // field_location_wrapper, so lat/lng are at wrapper[widget][0][latitude].
  if ($lat === NULL && $form_state->hasValue(['field_location_wrapper', 'widget', 0, 'latitude'])) {
    $lat_value = $form_state->getValue(['field_location_wrapper', 'widget', 0, 'latitude']);
    if ($lat_value !== NULL && $lat_value !== '' && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }
  if ($lng === NULL && $form_state->hasValue(['field_location_wrapper', 'widget', 0, 'longitude'])) {
    $lng_value = $form_state->getValue(['field_location_wrapper', 'widget', 0, 'longitude']);
    if ($lng_value !== NULL && $lng_value !== '' && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }
  if ($lat === NULL && isset($user_input['field_location_wrapper']['widget'][0]['latitude']) && is_numeric($user_input['field_location_wrapper']['widget'][0]['latitude'])) {
    $lat = (float) $user_input['field_location_wrapper']['widget'][0]['latitude'];
  }
  if ($lng === NULL && isset($user_input['field_location_wrapper']['widget'][0]['longitude']) && is_numeric($user_input['field_location_wrapper']['widget'][0]['longitude'])) {
    $lng = (float) $user_input['field_location_wrapper']['widget'][0]['longitude'];
  }

  // Save coordinates to dedicated fields if they exist and we have values.
  if ($lat !== NULL && $node->hasField('field_location_latitude')) {
    $node->set('field_location_latitude', $lat);
    \Drupal::logger('myeventlane_location')->notice('Saved latitude: @lat', ['@lat' => $lat]);
  }
  elseif ($lat !== NULL && $node->hasField('field_event_lat')) {
    $node->set('field_event_lat', (string) $lat);
    \Drupal::logger('myeventlane_location')->notice('Saved latitude (legacy): @lat', ['@lat' => $lat]);
  }
  else {
    \Drupal::logger('myeventlane_location')->warning('Latitude not saved. Lat: @lat, Has field: @has', [
      '@lat' => $lat ?? 'NULL',
      '@has' => $node->hasField('field_location_latitude') ? 'YES' : 'NO',
    ]);
  }

  if ($lng !== NULL && $node->hasField('field_location_longitude')) {
    $node->set('field_location_longitude', $lng);
    \Drupal::logger('myeventlane_location')->notice('Saved longitude: @lng', ['@lng' => $lng]);
  }
  elseif ($lng !== NULL && $node->hasField('field_event_lng')) {
    $node->set('field_event_lng', (string) $lng);
    \Drupal::logger('myeventlane_location')->notice('Saved longitude (legacy): @lng', ['@lng' => $lng]);
  }
  else {
    \Drupal::logger('myeventlane_location')->warning('Longitude not saved. Lng: @lng, Has field: @has', [
      '@lng' => $lng ?? 'NULL',
      '@has' => $node->hasField('field_location_longitude') ? 'YES' : 'NO',
    ]);
  }

  // Save when coordinates were set (wizard form saves before this handler runs).
  if ($lat !== NULL || $lng !== NULL) {
    $node->save();
  }
}

/**
 * Implements hook_page_attachments().
 */
function myeventlane_location_page_attachments(array &$attachments): void {
  // Only attach on Event node view pages.
  $route = \Drupal::routeMatch();
  if ($route->getRouteName() !== 'entity.node.canonical') {
    return;
  }

  $node = $route->getParameter('node');
  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    return;
  }

  // Check if event has location coordinates.
  $lat = NULL;
  $lng = NULL;

  // Try to get coordinates from dedicated fields first.
  if ($node->hasField('field_location_latitude') && !$node->get('field_location_latitude')->isEmpty()) {
    $lat = (float) $node->get('field_location_latitude')->value;
  }
  elseif ($node->hasField('field_event_lat') && !$node->get('field_event_lat')->isEmpty()) {
    $lat = (float) $node->get('field_event_lat')->value;
  }

  if ($node->hasField('field_location_longitude') && !$node->get('field_location_longitude')->isEmpty()) {
    $lng = (float) $node->get('field_location_longitude')->value;
  }
  elseif ($node->hasField('field_event_lng') && !$node->get('field_event_lng')->isEmpty()) {
    $lng = (float) $node->get('field_event_lng')->value;
  }

  // Only attach if we have coordinates.
  if ($lat !== NULL && $lng !== NULL) {
    // Attach map rendering library.
    $attachments['#attached']['library'][] = 'myeventlane_location/event_map';

    // Get provider settings.
    /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
    $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
    $settings = $provider_manager->getFrontendSettings();

    // For Apple Maps, generate token.
    if ($settings['provider'] === 'apple_maps') {
      /** @var \Drupal\myeventlane_location\Service\MapKitTokenGenerator $token_generator */
      $token_generator = \Drupal::service('myeventlane_location.mapkit_token_generator');
      $token = $token_generator->generateToken();
      if (!empty($token)) {
        $settings['apple_maps_token'] = $token;
      }
    }

    $attachments['#attached']['drupalSettings']['myeventlaneLocation'] = $settings;
    $attachments['#attached']['drupalSettings']['myeventlaneLocationEvent'] = [
      'latitude' => $lat,
      'longitude' => $lng,
      'title' => $node->getTitle(),
    ];
  }
}

/**
 * Implements hook_ENTITY_TYPE_view() for node entities.
 *
 * Adds map rendering to Event node views.
 */
function myeventlane_location_node_view(array &$build, EntityInterface $entity, $view_mode): void {
  // Only process event nodes in full/default view modes.
  if (!$entity instanceof NodeInterface || $entity->bundle() !== 'event') {
    return;
  }

  if (!in_array($view_mode, ['full', 'default'], TRUE)) {
    return;
  }

  // Get venue data from Venue entity (canonical source).
  $lat = NULL;
  $lng = NULL;
  $address = '';
  $venue_name = '';

  // First, try to get data from Venue entity (field_venue).
  if ($entity->hasField('field_venue') && !$entity->get('field_venue')->isEmpty()) {
    $venue = $entity->get('field_venue')->entity;
    if ($venue && $venue->getEntityTypeId() === 'myeventlane_venue') {
      // Get venue name.
      $venue_name = $venue->getName();

      // Get coordinates from venue.
      if ($venue->hasField('field_latitude') && !$venue->get('field_latitude')->isEmpty()) {
        $lat = (float) $venue->get('field_latitude')->value;
      }
      if ($venue->hasField('field_longitude') && !$venue->get('field_longitude')->isEmpty()) {
        $lng = (float) $venue->get('field_longitude')->value;
      }

      // Get address from venue.
      if ($venue->hasField('field_location') && !$venue->get('field_location')->isEmpty()) {
        $location_item = $venue->get('field_location')->first();
        if ($location_item) {
          $location = $location_item->getValue();
          if (is_array($location)) {
            $parts = [];
            if (!empty($location['address_line1'])) {
              $parts[] = $location['address_line1'];
            }
            if (!empty($location['locality'])) {
              $parts[] = $location['locality'];
            }
            if (!empty($location['administrative_area'])) {
              $parts[] = $location['administrative_area'];
            }
            if (!empty($location['postal_code'])) {
              $parts[] = $location['postal_code'];
            }
            $address = implode(', ', $parts);
          }
        }
      }
    }
  }

  // Fallback to legacy fields if venue entity not available.
  if ($lat === NULL && $entity->hasField('field_location_latitude') && !$entity->get('field_location_latitude')->isEmpty()) {
    $lat = (float) $entity->get('field_location_latitude')->value;
  }
  elseif ($lat === NULL && $entity->hasField('field_event_lat') && !$entity->get('field_event_lat')->isEmpty()) {
    $lat = (float) $entity->get('field_event_lat')->value;
  }
  // Try to extract lat from address field if available.
  // Address module may store coordinates in the value array.
  elseif ($lat === NULL && $entity->hasField('field_location') && !$entity->get('field_location')->isEmpty()) {
    $location_item = $entity->get('field_location')->first();
    if ($location_item) {
      $location_value = $location_item->getValue();
      // Check if latitude is in the value array.
      if (is_array($location_value) && isset($location_value['latitude']) && !empty($location_value['latitude']) && is_numeric($location_value['latitude'])) {
        $lat = (float) $location_value['latitude'];
      }
      // Also try hasProperty/get method.
      else {
        if ($location_item->hasProperty('latitude')) {
          $lat_value = $location_item->get('latitude')->getValue();
          if (!empty($lat_value) && is_numeric($lat_value)) {
            $lat = (float) $lat_value;
          }
        }
      }
    }
  }

  if ($lng === NULL && $entity->hasField('field_location_longitude') && !$entity->get('field_location_longitude')->isEmpty()) {
    $lng = (float) $entity->get('field_location_longitude')->value;
  }
  elseif ($lng === NULL && $entity->hasField('field_event_lng') && !$entity->get('field_event_lng')->isEmpty()) {
    $lng = (float) $entity->get('field_event_lng')->value;
  }
  // Try to extract lng from address field if available.
  elseif ($lng === NULL && $entity->hasField('field_location') && !$entity->get('field_location')->isEmpty()) {
    $location_item = $entity->get('field_location')->first();
    if ($location_item) {
      $location_value = $location_item->getValue();
      // Check if longitude is in the value array.
      if (is_array($location_value) && isset($location_value['longitude']) && !empty($location_value['longitude']) && is_numeric($location_value['longitude'])) {
        $lng = (float) $location_value['longitude'];
      }
      // Also try hasProperty/get method.
      else {
        if ($location_item->hasProperty('longitude')) {
          $lng_value = $location_item->get('longitude')->getValue();
          if (!empty($lng_value) && is_numeric($lng_value)) {
            $lng = (float) $lng_value;
          }
        }
      }
    }
  }

  // Fallback address from legacy fields.
  if (empty($address)) {
    $address_field = NULL;
    if ($entity->hasField('field_location') && !$entity->get('field_location')->isEmpty()) {
      $address_field = $entity->get('field_location');
    }
    elseif ($entity->hasField('field_event_address') && !$entity->get('field_event_address')->isEmpty()) {
      $address_field = $entity->get('field_event_address');
    }

    if ($address_field && !$address_field->isEmpty()) {
      $location_item = $address_field->first();
      if ($location_item) {
        $location = $location_item->getValue();
        if (is_array($location)) {
          $parts = [];
          if (!empty($location['address_line1'])) {
            $parts[] = $location['address_line1'];
          }
          if (!empty($location['locality'])) {
            $parts[] = $location['locality'];
          }
          if (!empty($location['administrative_area'])) {
            $parts[] = $location['administrative_area'];
          }
          if (!empty($location['postal_code'])) {
            $parts[] = $location['postal_code'];
          }
          $address = implode(', ', $parts);
        }
      }
    }
  }

  // Fallback venue name from legacy fields.
  if (empty($venue_name)) {
    if ($entity->hasField('field_venue_name') && !$entity->get('field_venue_name')->isEmpty()) {
      $venue_name = $entity->get('field_venue_name')->value;
    }
    elseif ($entity->hasField('field_event_venue') && !$entity->get('field_event_venue')->isEmpty()) {
      $venue_name = $entity->get('field_event_venue')->value;
    }
  }

  // Attach library and settings even if coordinates don't exist (for debugging).
  // Get provider settings.
  /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
  $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
  $settings = $provider_manager->getFrontendSettings();

  // For Apple Maps, generate token.
  if ($settings['provider'] === 'apple_maps') {
    /** @var \Drupal\myeventlane_location\Service\MapKitTokenGenerator $token_generator */
    $token_generator = \Drupal::service('myeventlane_location.mapkit_token_generator');
    $token = $token_generator->generateToken();
    if (!empty($token)) {
      $settings['apple_maps_token'] = $token;
    }
  }

  // Always attach library and settings to build (not just when coordinates exist).
  if (!isset($build['#attached'])) {
    $build['#attached'] = [];
  }
  if (!isset($build['#attached']['library'])) {
    $build['#attached']['library'] = [];
  }
  if (!isset($build['#attached']['drupalSettings'])) {
    $build['#attached']['drupalSettings'] = [];
  }

  $build['#attached']['library'][] = 'myeventlane_location/event_map';
  $build['#attached']['drupalSettings']['myeventlaneLocation'] = $settings;

  // Only add map if coordinates exist.
  if ($lat !== NULL && $lng !== NULL) {
    $provider = $provider_manager->getDefaultProvider();

    // Add event coordinates to drupalSettings.
    $build['#attached']['drupalSettings']['myeventlaneLocationEvent'] = [
      'latitude' => $lat,
      'longitude' => $lng,
      'title' => $entity->label(),
      'address' => $address,
      'venue_name' => $venue_name,
    ];

    // Add map to build array.
    $build['event_location_map'] = [
      '#theme' => 'event_location_map',
      '#event' => $entity,
      '#latitude' => $lat,
      '#longitude' => $lng,
      '#address' => $address,
      '#venue_name' => $venue_name,
      '#provider' => $provider,
      '#weight' => 100,
      '#attached' => [
        'library' => ['myeventlane_location/event_map_toggle'],
      ],
      '#cache' => [
        'tags' => $entity->getCacheTags(),
        'contexts' => ['url.path'],
      ],
    ];
  }
  else {
    // Even without coordinates, set empty event data so JS knows to skip map.
    $build['#attached']['drupalSettings']['myeventlaneLocationEvent'] = [
      'latitude' => NULL,
      'longitude' => NULL,
      'title' => $entity->label(),
      'address' => $address,
      'venue_name' => $venue_name,
    ];
  }

  // Even if no coordinates, add venue name and address info if available.
  if (($lat === NULL || $lng === NULL) && (!empty($venue_name) || !empty($address))) {
    $build['event_location_info'] = [
      '#theme' => 'event_location_info',
      '#event' => $entity,
      '#address' => $address,
      '#venue_name' => $venue_name,
      '#weight' => 100,
      '#cache' => [
        'tags' => $entity->getCacheTags(),
        'contexts' => ['url.path'],
      ],
    ];
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Fallback geocoding to ensure latitude/longitude are always populated
 * when an address exists but coordinates are missing.
 */
function myeventlane_location_entity_presave(EntityInterface $entity): void {
  if (!$entity instanceof NodeInterface || $entity->bundle() !== 'event') {
    return;
  }

  if (!$entity->hasField('field_location')) {
    return;
  }

  // If coords already exist, do nothing.
  if (
    $entity->hasField('field_location_latitude') &&
    $entity->hasField('field_location_longitude') &&
    !$entity->get('field_location_latitude')->isEmpty() &&
    !$entity->get('field_location_longitude')->isEmpty()
  ) {
    return;
  }

  if ($entity->get('field_location')->isEmpty()) {
    return;
  }

  $location = $entity->get('field_location')->first()->getValue();
  if (empty($location)) {
    return;
  }

  $parts = array_filter([
    $location['address_line1'] ?? '',
    $location['locality'] ?? '',
    $location['administrative_area'] ?? '',
    $location['postal_code'] ?? '',
    $location['country_code'] ?? '',
  ]);

  if (empty($parts)) {
    return;
  }

  /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
  $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
  $settings = $provider_manager->getFrontendSettings();

  if (empty($settings['google_maps_api_key'])) {
    \Drupal::logger('myeventlane_location')->warning('No Google Maps API key available for fallback geocoding.');
    return;
  }

  $query = urlencode(implode(', ', $parts));
  $url = sprintf(
    'https://maps.googleapis.com/maps/api/geocode/json?address=%s&key=%s',
    $query,
    $settings['google_maps_api_key']
  );

  $response = @file_get_contents($url);
  if (!$response) {
    return;
  }

  $data = json_decode($response, TRUE);
  if (empty($data['results'][0]['geometry']['location'])) {
    return;
  }

  $coords = $data['results'][0]['geometry']['location'];

  if ($entity->hasField('field_location_latitude')) {
    $entity->set('field_location_latitude', (float) $coords['lat']);
  }

  if ($entity->hasField('field_location_longitude')) {
    $entity->set('field_location_longitude', (float) $coords['lng']);
  }

  \Drupal::logger('myeventlane_location')->notice(
    'Fallback geocoded event @nid to @lat,@lng',
    [
      '@nid' => $entity->id(),
      '@lat' => $coords['lat'],
      '@lng' => $coords['lng'],
    ]
  );
}

/**
 * Hides unused address subfields (organization, given_name, family_name) from all address fields.
 *
 * @param array &$form
 *   The form array (passed by reference).
 */
function _myeventlane_location_hide_unused_address_fields(array &$form): void {
  $unused_fields = ['organization', 'given_name', 'family_name'];
  $address_fields = ['field_location', 'field_venue_address'];

  foreach ($address_fields as $field_name) {
    // Check multiple possible form paths.
    $paths = [
      [$field_name],
      ['wizard', 'content', '_venue_wrapper', $field_name],
      ['wizard', 'content', $field_name],
      ['mel_wizard', 'layout', 'content'],
    ];

    foreach ($paths as $path) {
      $field_ref = &$form;
      $found = TRUE;
      foreach ($path as $key) {
        if (isset($field_ref[$key])) {
          $field_ref = &$field_ref[$key];
        }
        else {
          $found = FALSE;
          break;
        }
      }

      if ($found && isset($field_ref['widget']) && is_array($field_ref['widget'])) {
        foreach ($field_ref['widget'] as $delta => &$widget_item) {
          if (is_numeric($delta) && isset($widget_item['address']) && is_array($widget_item['address'])) {
            foreach ($unused_fields as $unused_field) {
              if (isset($widget_item['address'][$unused_field])) {
                $widget_item['address'][$unused_field]['#access'] = FALSE;
                $widget_item['address'][$unused_field]['#required'] = FALSE;
                $widget_item['address'][$unused_field]['#printed'] = TRUE;
                unset($widget_item['address'][$unused_field]);
              }
            }
          }
        }
      }
    }
  }

  // Also recursively search the entire form for address widgets.
  _myeventlane_location_hide_unused_address_fields_recursive($form, $unused_fields);
}

/**
 * Recursively hides unused address fields in form structure.
 *
 * @param array &$element
 *   Form element to process (passed by reference).
 * @param array $unused_fields
 *   Array of field names to hide.
 */
function _myeventlane_location_hide_unused_address_fields_recursive(array &$element, array $unused_fields): void {
  if (!is_array($element)) {
    return;
  }

  foreach ($element as $key => &$value) {
    // Skip metadata keys.
    if (is_string($key) && str_starts_with($key, '#')) {
      continue;
    }

    // Check if this is an address widget structure.
    if (is_array($value) && isset($value['address']) && is_array($value['address'])) {
      foreach ($unused_fields as $field_name) {
        if (isset($value['address'][$field_name])) {
          $value['address'][$field_name]['#access'] = FALSE;
          $value['address'][$field_name]['#required'] = FALSE;
          $value['address'][$field_name]['#printed'] = TRUE;
          unset($value['address'][$field_name]);
        }
      }
    }

    // Recursively process nested arrays.
    if (is_array($value)) {
      _myeventlane_location_hide_unused_address_fields_recursive($value, $unused_fields);
    }
  }
}
