<?php

/**
 * @file
 * Theme hooks for MyEventLane.
 */

use Drupal\Core\Render\Element;
use Drupal\Core\Routing\RouteNotFoundException;
use Drupal\taxonomy\TermInterface;
use Drupal\node\NodeInterface;
use Drupal\file\Entity\File;

/**
 * Implements hook_preprocess_html().
 */
function myeventlane_theme_preprocess_html(array &$variables) {
  // Add any HTML-level preprocessing here if needed.
}

/**
 * Implements hook_preprocess_page().
 *
 * Adds cart block to header if not already placed.
 */
function myeventlane_theme_preprocess_page(array &$variables): void {
  // Add logo path for header.
  $theme_path = \Drupal::service('extension.list.theme')->getPath('myeventlane_theme');
  $variables['logo_path'] = base_path() . $theme_path . '/images/logo.svg';
  
  // Ensure directory variable is available for all templates (especially homepage hero).
  if (!isset($variables['directory'])) {
    $variables['directory'] = base_path() . $theme_path;
  }
  
  // Check if vendor settings route exists for header menu.
  $route_exists = FALSE;

  try {
    \Drupal::service('router.route_provider')
      ->getRouteByName('myeventlane_vendor.console.settings');
    $route_exists = TRUE;
  }
  catch (RouteNotFoundException $e) {
    $route_exists = FALSE;
  }

  $variables['mel_vendor_settings_route_exists'] = $route_exists;
  
  // Ensure header region blocks are available even if region template isn't used.
  // Initialize header array if not set.
  if (!isset($variables['page']['header'])) {
    $variables['page']['header'] = [];
  }
  
  // Load main menu block manually since page.html.twig includes header template directly
  // without rendering {{ page.header }} first, so blocks aren't automatically added.
  if (empty($variables['page']['header']['main_menu']) && empty($variables['page']['header']['myeventlane_theme_main_menu'])) {
    try {
      $block_storage = \Drupal::entityTypeManager()->getStorage('block');
      $block = $block_storage->load('myeventlane_theme_main_menu');
      if ($block && $block->status() && $block->getRegion() === 'header') {
        $block_plugin = $block->getPlugin();
        $current_user = \Drupal::currentUser();
        if ($block_plugin->access($current_user)) {
          $build = $block_plugin->build();
          if (!empty($build) && is_array($build)) {
            // Ensure the build array is renderable
            $variables['page']['header']['main_menu'] = $build;
          }
        }
      }
    }
    catch (\Exception $e) {
      // Block load/build failed, log and continue
      \Drupal::logger('myeventlane_theme')->warning('Failed to load main menu block: @message', ['@message' => $e->getMessage()]);
    }
  }
  
  // Map main menu block to expected variable name if it exists with block ID key.
  // This handles the case where Drupal renders the region normally.
  if (!empty($variables['page']['header']['myeventlane_theme_main_menu']) && empty($variables['page']['header']['main_menu'])) {
    $variables['page']['header']['main_menu'] = $variables['page']['header']['myeventlane_theme_main_menu'];
  }
  
  // Add cart block to header if not already present
  if (empty($variables['page']['header']['cart_block'])) {
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $cart_block = $block_manager->createInstance('commerce_cart', []);
      if ($cart_block && $cart_block->access(\Drupal::currentUser())) {
        $build = $cart_block->build();
        if (!empty($build)) {
          $variables['page']['header']['cart_block'] = $build;
        }
      }
    } catch (\Exception $e) {
      // Cart block not available, continue without it
    }
  }
  
  // Front page specific processing
  // Check if this is the front page.
  if (\Drupal::service('path.matcher')->isFrontPage()) {
    // Load category terms.
    $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $terms = $term_storage->loadByProperties(['vid' => 'categories']);
    
    $categories = [];
    foreach ($terms as $term) {
      $slug = _myeventlane_theme_get_category_slug($term);
      $categories[] = [
        'tid' => $term->id(),
        'name' => $term->label(),
        'label' => $term->label(),
        'url' => '/events/category/' . $term->id(),
        'slug' => $slug,
      ];
    }
    
    $variables['event_categories'] = $categories;
    
    // Add calendar data for mini calendar
    $variables['calendar'] = _myeventlane_theme_get_calendar_data();
  }
  
  // MyEventLane Illustration System: Category-aware hero swaps.
  // Category pages MUST use category banners from /images/mel/categories/.
  // Homepage MUST ALWAYS use journey hero images.
  // Category pages NEVER show journey hero (only fallback if banner missing).
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();
  $extension_list = \Drupal::service('extension.list.theme');
  $theme_path = $extension_list->getPath('myeventlane_theme');
  $is_front_page = \Drupal::service('path.matcher')->isFrontPage();
  
  $category_slug = NULL;
  $category_term = NULL;
  
  // Detect category context: taxonomy.term route ONLY.
  // Do NOT detect via views or query params - use route only.
  if ($route_name === 'entity.taxonomy_term.canonical') {
    $term = $route_match->getParameter('taxonomy_term');
    if ($term && $term->bundle() === 'categories') {
      $category_term = $term;
      // Get category slug using helper function (handles field_mel_slug or fallback to sanitized name).
      $category_slug = _myeventlane_theme_get_category_slug($term);
    }
  }
  
  // Build hero URLs based on page type.
  $hero_desktop_url = NULL;
  $hero_mobile_url = NULL;
  $base_url = base_path();
  
  // Category pages: Use category banner directly from /images/mel/categories/.
  // Category pages override hero - homepage never overridden.
  if ($category_slug && !$is_front_page) {
    // Map category slug to match actual banner file names.
    // File names: mel-category-arts.png, mel-category-lgbtqia.png, etc.
    $slug_to_filename_map = [
      'lgbtqi' => 'lgbtqia',  // LGBTQI+ term → lgbtqia file
      'food-drink' => 'food', // Food & Drink term → food file
      // All other slugs should match: music, workshop, arts, community, markets, family
    ];
    
    $banner_slug = $slug_to_filename_map[$category_slug] ?? $category_slug;
    
    // Category page: Use category banner as hero.
    // Desktop: images/mel/categories/mel-category-{slug}.png
    $banner_desktop_relative = $theme_path . '/images/mel/categories/mel-category-' . $banner_slug . '.png';
    $banner_desktop_path = DRUPAL_ROOT . '/' . $banner_desktop_relative;
    
    if (file_exists($banner_desktop_path)) {
      $hero_desktop_url = $base_url . $banner_desktop_relative;
    }
    
    // Mobile: Same category banner (acceptable per requirements).
    // If a mobile-specific version exists later, it can be added.
    if ($hero_desktop_url) {
      $hero_mobile_url = $hero_desktop_url;
    }
    
    // Fallback: If category banner doesn't exist, use journey hero (rare case).
    if (!$hero_desktop_url) {
      $journey_desktop_relative = $theme_path . '/images/mel/hero/mel-hero-journey-desktop.png';
      $journey_desktop_path = DRUPAL_ROOT . '/' . $journey_desktop_relative;
      $journey_mobile_relative = $theme_path . '/images/mel/hero/mel-hero-journey-mobile.png';
      $journey_mobile_path = DRUPAL_ROOT . '/' . $journey_mobile_relative;
      
      if (file_exists($journey_desktop_path)) {
        $hero_desktop_url = $base_url . $journey_desktop_relative;
      }
      if (file_exists($journey_mobile_path)) {
        $hero_mobile_url = $base_url . $journey_mobile_relative;
      }
    }
  }
  
  // Homepage: ALWAYS use journey hero images.
  // Homepage never uses category banners.
  if ($is_front_page) {
    $journey_desktop_relative = $theme_path . '/images/mel/hero/mel-hero-journey-desktop.png';
    $journey_desktop_path = DRUPAL_ROOT . '/' . $journey_desktop_relative;
    $journey_mobile_relative = $theme_path . '/images/mel/hero/mel-hero-journey-mobile.png';
    $journey_mobile_path = DRUPAL_ROOT . '/' . $journey_mobile_relative;
    
    if (file_exists($journey_desktop_path)) {
      $hero_desktop_url = $base_url . $journey_desktop_relative;
    }
    if (file_exists($journey_mobile_path)) {
      $hero_mobile_url = $base_url . $journey_mobile_relative;
    }
  }
  
  // Ensure directory variable is available for hero fallback in templates.
  if (!isset($variables['directory'])) {
    $variables['directory'] = base_path() . $theme_path;
  }
  
  // Set variables for Twig templates.
  $variables['mel_hero_desktop_url'] = $hero_desktop_url;
  $variables['mel_hero_mobile_url'] = $hero_mobile_url;
  $variables['mel_category_slug'] = $category_slug;
}

/**
 * Helper function to generate calendar data.
 */
function _myeventlane_theme_get_calendar_data($year = NULL, $month = NULL): array {
  $year = $year ?: date('Y');
  $month = $month ?: date('n');
  
  $first_day = mktime(0, 0, 0, $month, 1, $year);
  $days_in_month = date('t', $first_day);
  $start_day = date('w', $first_day); // 0 = Sunday
  
  // Get events for this month
  $start_date = date('Y-m-01', $first_day);
  $end_date = date('Y-m-t', $first_day);
  
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->condition('field_event_start', $start_date, '>=')
    ->condition('field_event_start', $end_date . 'T23:59:59', '<=')
    ->accessCheck(TRUE);
  
  $nids = $query->execute();
  $events_by_day = [];
  
  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);
    foreach ($nodes as $node) {
      $event_date = $node->get('field_event_start')->value;
      $day = (int) date('j', strtotime($event_date));
      if (!isset($events_by_day[$day])) {
        $events_by_day[$day] = [];
      }
      $events_by_day[$day][] = [
        'title' => $node->label(),
        'url' => $node->toUrl()->toString(),
      ];
    }
  }
  
  return [
    'year' => $year,
    'month' => $month,
    'month_name' => date('F', $first_day),
    'days_in_month' => $days_in_month,
    'start_day' => $start_day,
    'today' => (int) date('j'),
    'is_current_month' => ($year == date('Y') && $month == date('n')),
    'events_by_day' => $events_by_day,
  ];
}

/**
 * Implements hook_preprocess_page() for category pages.
 *
 * Adds category info and all categories for the hero section.
 */
function myeventlane_theme_preprocess_page__events__category(array &$variables): void {
  // Get the category term ID from the URL.
  $tid = \Drupal::routeMatch()->getParameter('arg_0');
  
  if ($tid) {
    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tid);
    if ($term) {
      $variables['current_category'] = [
        'tid' => $term->id(),
        'name' => $term->label(),
      ];
    }
  }
  
  // Load all categories for the hero chips.
  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  $terms = $term_storage->loadByProperties(['vid' => 'categories']);
  
  $categories = [];
  foreach ($terms as $term) {
    $slug = _myeventlane_theme_get_category_slug($term);
    $categories[] = [
      'tid' => $term->id(),
      'name' => $term->label(),
      'label' => $term->label(),
      'url' => '/events/category/' . $term->id(),
      'slug' => $slug,
    ];
  }
  
  $variables['event_categories'] = $categories;
  // Also set as mel_header_categories if used by page header component.
  $variables['mel_header_categories'] = $categories;
}

/**
 * Implements hook_preprocess_page() for calendar page.
 */
function myeventlane_theme_preprocess_page__calendar(array &$variables): void {
  // Load all published events for the calendar.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->accessCheck(TRUE);

  $nids = $query->execute();
  $events = [];

  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);
    
    // Category colors.
    $category_colors = [
      'music' => '#7c5cff',
      'sports' => '#ff6f61',
      'food' => '#ffd46f',
      'arts' => '#4ecdc4',
      'business' => '#1a1a2e',
      'community' => '#ff6f61',
      'education' => '#4ecdc4',
      'charity' => '#ff6f61',
    ];

    foreach ($nodes as $node) {
      $start = $node->get('field_event_start')->value;
      $end = $node->hasField('field_event_end') ? $node->get('field_event_end')->value : NULL;
      
      // Get category color.
      $color = '#7c5cff';
      if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
        $category = $node->get('field_category')->entity;
        if ($category) {
          $cat_name = strtolower($category->label());
          $color = $category_colors[$cat_name] ?? '#7c5cff';
        }
      }

      if ($start) {
        $events[] = [
          'title' => $node->label(),
          'start' => $start,
          'end' => $end,
          'url' => $node->toUrl()->toString(),
          'color' => $color,
        ];
      }
    }
  }

  $variables['calendar_events'] = $events;
}

/**
 * Implements hook_library_info_alter().
 *
 * Dynamically rewrites the 'global-styling' library to point to the current
 * Vite-built CSS file defined in the manifest. This allows hashed filenames
 * generated by Vite (e.g. main.BMgQme3h.css) to be used automatically.
 */
function myeventlane_theme_library_info_alter(array &$libraries, string $extension): void {
  // Only alter this theme's own libraries.
  if ($extension !== 'myeventlane_theme') {
    return;
  }

  // Ensure our library exists before altering it.
  if (!isset($libraries['global-styling'])) {
    return;
  }

  $css_path = _myeventlane_theme_manifest_css();
  if (!$css_path) {
    // Gracefully fallback to whatever the .libraries.yml defines.
    return;
  }

  // Replace the existing CSS with only the hashed Vite output.
  $libraries['global-styling']['css']['theme'] = [
    $css_path => [],
  ];
}

/**
 * Reads the Vite manifest and returns the primary CSS file.
 *
 * @return string|null
 *   Relative path to the CSS file (e.g. 'dist/assets/main.ABC123.css'),
 *   or NULL if the manifest or asset cannot be read.
 */
function _myeventlane_theme_manifest_css(): ?string {
  static $cached = NULL;

  // Return cached value if already processed.
  if ($cached !== NULL) {
    return $cached;
  }

  // Load the theme path.
  $theme_handler = \Drupal::service('extension.list.theme');
  $relative_theme_path = $theme_handler->getPath('myeventlane_theme');

  // Vite manifest path.
  $manifest_path = DRUPAL_ROOT . '/' . $relative_theme_path . '/dist/.vite/manifest.json';
  if (!file_exists($manifest_path)) {
    return $cached = NULL;
  }

  $json = file_get_contents($manifest_path);
  if (!$json) {
    return $cached = NULL;
  }

  $manifest = json_decode($json, TRUE);
  if (!is_array($manifest)) {
    return $cached = NULL;
  }

  // Vite default entry: js/main.js → CSS array.
  if (empty($manifest['js/main.js']['css'][0])) {
    return $cached = NULL;
  }

  // Build theme-relative path.
  $css = $manifest['js/main.js']['css'][0];
  $css = ltrim($css, '/');

  return $cached = "dist/{$css}";
}

/**
 * Implements hook_preprocess_node().
 *
 * Adds classes and context for event form pages.
 * Adds MyEventLane illustration system variables for event nodes.
 * For event card view modes, prepares variables for mel-event-card component.
 */
function myeventlane_theme_preprocess_node(array &$variables): void {
  $node = $variables['node'];
  $view_mode = $variables['view_mode'] ?? 'full';

  // Check if this is an event node.
  if ($node && $node->bundle() === 'event') {
    // For form view mode, suggest the form template
    if ($view_mode === 'form' || (isset($variables['form']) && $variables['form'])) {
      $variables['attributes']['class'][] = 'mel-node-form';
      $variables['attributes']['class'][] = 'mel-node-form--event';
      // Suggest the form template
      $variables['theme_hook_suggestions'][] = 'node__event__form';
    }

    // MyEventLane Illustration System: Compute image URL, category slug, and placeholder URL.
    $file_url_generator = \Drupal::service('file_url_generator');
    $extension_list = \Drupal::service('extension.list.theme');
    $theme_path = $extension_list->getPath('myeventlane_theme');
    $base_path = base_path();

    // Ensure directory variable is available to node templates/components.
    // Many templates include components with `only`, which drops outer-scope
    // variables; by setting it here we can pass it explicitly when needed.
    if (!isset($variables['directory'])) {
      $variables['directory'] = $base_path . $theme_path;
    }
    
    // 1. Compute event image URL if it exists.
    $event_image_url = NULL;
    if ($node->hasField('field_event_image') && !$node->get('field_event_image')->isEmpty()) {
      $image_entity = $node->get('field_event_image')->entity;
      if ($image_entity) {
        $uri = $image_entity->getFileUri();
        $event_image_url = $file_url_generator->generateAbsoluteString($uri);
      }
    }
    $variables['mel_event_image_url'] = $event_image_url;

    // 2. Determine category slug from first category term and add category info for pills.
    // Handle multi-value field (cardinality: -1) by getting first referenced entity.
    $category_slug = 'default';
    $category_label = NULL;
    $category_url = NULL;
    if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
      $category_field = $node->get('field_category');
      // For multi-value fields, use referencedEntities() and get first one
      $referenced_entities = $category_field->referencedEntities();
      if (!empty($referenced_entities)) {
        $category_term = reset($referenced_entities);
        if ($category_term instanceof \Drupal\taxonomy\Entity\Term) {
          $category_slug = _myeventlane_theme_get_category_slug($category_term);
          $category_label = $category_term->label();
          $category_url = $category_term->toUrl()->toString();
        }
      }
    }
    
    // Normalize lgbtqi+ variants to lgbtqia for consistency
    if (in_array($category_slug, ['lgbtqi', 'lgbtq', 'lgbtqi+', 'lgbtqia+'], TRUE)) {
      $category_slug = 'lgbtqia';
    }
    
    $variables['mel_category_slug'] = $category_slug;
    $variables['mel_category_label'] = $category_label;
    $variables['mel_category_url'] = $category_url;

    // 3. Build placeholder URL: {theme}/images/mel/placeholders/mel-placeholder-{slug}.png
    // Check if placeholder file exists, otherwise fallback to default
    $placeholder_filename = 'mel-placeholder-' . $category_slug . '.png';
    $placeholder_relative_path = $theme_path . '/images/mel/placeholders/' . $placeholder_filename;
    $placeholder_file_path = DRUPAL_ROOT . '/' . $placeholder_relative_path;
    
    // If category-specific placeholder doesn't exist, use default
    if (!file_exists($placeholder_file_path)) {
      $placeholder_filename = 'mel-placeholder-default.png';
      $placeholder_relative_path = $theme_path . '/images/mel/placeholders/' . $placeholder_filename;
      $placeholder_file_path = DRUPAL_ROOT . '/' . $placeholder_relative_path;
    }
    
    // Only set placeholder URL if file actually exists (cache-safe check)
    $placeholder_url = NULL;
    if (file_exists($placeholder_file_path)) {
      $placeholder_url = $base_path . $placeholder_relative_path;
    }
    $variables['mel_placeholder_image_url'] = $placeholder_url;
    $variables['mel_fallback_image_url'] = $placeholder_url;

    // 4. For card view modes, prepare variables for mel-event-card component
    $card_view_modes = ['card', 'event_card', 'teaser', 'event_card_poster', 'event_card_compact'];
    if (in_array($view_mode, $card_view_modes, TRUE)) {
      // Card image URL: priority A) event image, B) category placeholder, C) default placeholder
      $card_image_url = $event_image_url;
      $is_placeholder = FALSE;
      if (!$card_image_url && $placeholder_url) {
        $card_image_url = $placeholder_url;
        $is_placeholder = TRUE;
      }
      $variables['mel_card_image_url'] = $card_image_url;
      $variables['mel_card_is_placeholder'] = $is_placeholder;

      // Note: Offset classes are now handled via CSS :nth-child selectors
      // in _mel-lane-cards.scss for reliability across Views and contexts.
      // No need to set mel_lane_offset_class - CSS handles the pattern.

      // Category pill classes
      $pill_classes = 'mel-category-pill mel-category-pill--' . $category_slug . ' mel-category-pill--sm';
      $variables['mel_category_pill_classes'] = $pill_classes;
      $variables['mel_category_name'] = $category_label;
      $variables['mel_category_slug'] = $category_slug;

      // Badge text: FREE, price, or "Tickets"
      $variables['mel_card_badge_text'] = _myeventlane_theme_get_event_badge_text($node);

      // Card URL
      $variables['mel_card_url'] = $node->toUrl()->toString();

      // Date/time (when)
      $when_text = NULL;
      if ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty()) {
        $start_value = $node->get('field_event_start')->value;
        if ($start_value) {
          $start_timestamp = strtotime($start_value);
          if ($start_timestamp) {
            // Format: "D j M, g:ia" e.g. "Sat 15 Mar, 7:00pm"
            $when_text = date('D j M, g:ia', $start_timestamp);
          }
        }
      }
      $variables['mel_card_when'] = $when_text;

      // Venue/location (where)
      $where_text = NULL;
      if ($node->hasField('field_venue_name') && !$node->get('field_venue_name')->isEmpty()) {
        $where_text = $node->get('field_venue_name')->value;
      }
      elseif ($node->hasField('field_location') && !$node->get('field_location')->isEmpty()) {
        $location_item = $node->get('field_location')->first();
        if ($location_item) {
          $locality = $location_item->get('locality')->getValue();
          $administrative_area = $location_item->get('administrative_area')->getValue();
          if ($locality) {
            $where_text = $locality;
            if ($administrative_area) {
              $where_text .= ', ' . $administrative_area;
            }
          }
        }
      }
      $variables['mel_card_where'] = $where_text;

      // Add cache contexts/tags
      if (!isset($variables['#cache']['contexts'])) {
        $variables['#cache']['contexts'] = [];
      }
      $variables['#cache']['contexts'][] = 'route';
      if (!isset($variables['#cache']['tags'])) {
        $variables['#cache']['tags'] = [];
      }
      // Add taxonomy term cache tag if category exists
      if ($category_term ?? NULL) {
        $variables['#cache']['tags'][] = 'taxonomy_term:' . $category_term->id();
      }
    }
  }
}

/**
 * Helper function to compute event badge text from event type and price.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The event node.
 *
 * @return string|null
 *   Badge text: "FREE", "$XX.XX", "Tickets", or NULL.
 */
function _myeventlane_theme_get_event_badge_text(\Drupal\node\NodeInterface $node): ?string {
  if ($node->bundle() !== 'event') {
    return NULL;
  }

  $event_type = NULL;
  if ($node->hasField('field_event_type') && !$node->get('field_event_type')->isEmpty()) {
    $event_type = $node->get('field_event_type')->value;
  }

  // RSVP or "both" with free price → "FREE"
  if ($event_type === 'rsvp') {
    return 'FREE';
  }

  // Check if product exists and get price
  $product = NULL;
  if ($node->hasField('field_product_target') && !$node->get('field_product_target')->isEmpty()) {
    $product = $node->get('field_product_target')->entity;
  }

  if ($product) {
    $default_variation = $product->getDefaultVariation();
    if ($default_variation && $default_variation->hasField('price') && !$default_variation->get('price')->isEmpty()) {
      $price = $default_variation->getPrice();
      if ($price) {
        $price_number = $price->getNumber();
        // If price is 0 and event type is "both", still show FREE for clarity
        if ($price_number === '0' && ($event_type === 'both' || $event_type === 'rsvp')) {
          return 'FREE';
        }
        // If price > 0, format and return
        if ($price_number > 0) {
          return '$' . number_format($price_number, 2);
        }
      }
    }
  }

  // Paid or "both" without price info → "Tickets"
  if (in_array($event_type, ['paid', 'both', 'external'], TRUE)) {
    return 'Tickets';
  }

  return NULL;
}

/**
 * Implements hook_preprocess_views_view_fields().
 *
 * Adds directory path for MyEventLane illustration system in views.
 * Sets mel_is_event_view flag and prepares variables for event card component.
 */
function myeventlane_theme_preprocess_views_view_fields(array &$variables): void {
  // Add theme directory path for image placeholders.
  if (!isset($variables['directory'])) {
    $extension_list = \Drupal::service('extension.list.theme');
    $theme_path = $extension_list->getPath('myeventlane_theme');
    $base_path = base_path();
    $variables['directory'] = $base_path . $theme_path;
  }

  // Detect if this is an event view by checking view ID and fields
  $view = $variables['view'] ?? NULL;
  $is_event_view = FALSE;
  if ($view) {
    $view_id = $view->id();
    // Check if view ID contains "event" or if fields contain event-specific fields
    if (strpos($view_id, 'event') !== FALSE) {
      $is_event_view = TRUE;
    }
    // Also check if fields contain event-specific field names
    elseif (isset($variables['fields'])) {
      $field_keys = array_keys($variables['fields']);
      $event_fields = ['field_event', 'field_category', 'field_event_start', 'field_venue_name'];
      foreach ($event_fields as $event_field) {
        if (in_array($event_field, $field_keys, TRUE)) {
          $is_event_view = TRUE;
          break;
        }
      }
    }
  }
  $variables['mel_is_event_view'] = $is_event_view;
}

/**
 * Implements hook_preprocess_taxonomy_term().
 *
 * Adds MyEventLane illustration system variables for category terms.
 * Computes category banner URL using file_url_generator and checks file existence.
 * Adds all categories with slugs for header pills.
 */
function myeventlane_theme_preprocess_taxonomy_term(array &$variables): void {
  $term = $variables['term'];
  
  // Only process category terms.
  if ($term && $term->bundle() === 'categories') {
    // Get category slug from field_mel_slug.
    $category_slug = NULL;
    if ($term->hasField('field_mel_slug') && !$term->get('field_mel_slug')->isEmpty()) {
      $slug_value = $term->get('field_mel_slug')->value;
      if (!empty($slug_value)) {
        $category_slug = $slug_value;
      }
    }
    
    $variables['mel_category_slug'] = $category_slug;
    
    // Build banner URL if slug exists and file exists.
    $banner_url = NULL;
    if ($category_slug) {
      $extension_list = \Drupal::service('extension.list.theme');
      $theme_path = $extension_list->getPath('myeventlane_theme');
      $banner_relative_path = $theme_path . '/images/mel/categories/mel-category-' . $category_slug . '.png';
      $banner_file_path = DRUPAL_ROOT . '/' . $banner_relative_path;
      
      // Check if file exists before generating URL.
      if (file_exists($banner_file_path)) {
        // For theme files, use base_path() to generate URL.
        // Note: file_url_generator is designed for managed file entities (public://, private:// URIs).
        // Theme files are not managed files, so base_path() is the standard Drupal approach.
        $banner_url = base_path() . $banner_relative_path;
      }
    }
    
    $variables['mel_category_banner_url'] = $banner_url;
    
    // Load all categories with slugs for header pills.
    $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $all_terms = $term_storage->loadByProperties(['vid' => 'categories']);
    
    $categories = [];
    foreach ($all_terms as $cat_term) {
      $slug = _myeventlane_theme_get_category_slug($cat_term);
      $categories[] = [
        'tid' => $cat_term->id(),
        'name' => $cat_term->label(),
        'label' => $cat_term->label(),
        'url' => '/events/category/' . $cat_term->id(),
        'slug' => $slug,
      ];
    }
    
    $variables['mel_header_categories'] = $categories;
  }
}

/**
 * Implements hook_preprocess_views_view().
 *
 * Injects category banner into views headers on taxonomy term pages.
 */
function myeventlane_theme_preprocess_views_view(array &$variables): void {
  $view = $variables['view'];
  
  // Only process views on taxonomy term pages.
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();
  
  if ($route_name === 'entity.taxonomy_term.canonical') {
    // Get the taxonomy term from route.
    $term = $route_match->getParameter('taxonomy_term');
    
    if ($term && $term->bundle() === 'categories') {
      // Get category slug from field_mel_slug.
      $category_slug = NULL;
      if ($term->hasField('field_mel_slug') && !$term->get('field_mel_slug')->isEmpty()) {
        $slug_value = $term->get('field_mel_slug')->value;
        if (!empty($slug_value)) {
          $category_slug = $slug_value;
        }
      }
      
      $variables['mel_category_slug'] = $category_slug;
      
      // Build banner URL if slug exists and file exists.
      $banner_url = NULL;
      if ($category_slug) {
        $extension_list = \Drupal::service('extension.list.theme');
        $theme_path = $extension_list->getPath('myeventlane_theme');
        $banner_relative_path = $theme_path . '/images/mel/categories/mel-category-' . $category_slug . '.png';
        $banner_file_path = DRUPAL_ROOT . '/' . $banner_relative_path;
        
        // Check if file exists before generating URL.
        if (file_exists($banner_file_path)) {
          // For theme files, construct URL manually (not file entities, so can't use file_url_generator).
          $banner_url = base_path() . $banner_relative_path;
        }
      }
      
      $variables['mel_category_banner_url'] = $banner_url;
    }
  }
}

/**
 * Helper function to get category slug from taxonomy term.
 *
 * @param \Drupal\taxonomy\TermInterface|null $term
 *   The taxonomy term entity, or NULL.
 *
 * @return string
 *   The category slug (from field_mel_slug or sanitized term name), or 'default'.
 *   Normalizes lgbtqi+ variants to 'lgbtqia'.
 */
function _myeventlane_theme_get_category_slug(?TermInterface $term): string {
  if (!$term || $term->bundle() !== 'categories') {
    return 'default';
  }
  
  // First priority: field_mel_slug (preferred).
  $slug = 'default';
  if ($term->hasField('field_mel_slug') && !$term->get('field_mel_slug')->isEmpty()) {
    $slug_value = $term->get('field_mel_slug')->value;
    if (!empty($slug_value)) {
      $slug = trim(strtolower($slug_value));
    }
  }
  else {
    // Fallback: sanitize term name.
    $name = $term->label();
    $slug = strtolower($name);
    // Replace & with "and", replace non-alphanumeric with hyphen
    $slug = str_replace('&', 'and', $slug);
    $slug = preg_replace('/[^a-z0-9]+/', '-', $slug);
    $slug = trim($slug, '-');
  }
  
  // Normalize lgbtqi+ variants to lgbtqia
  if (in_array($slug, ['lgbtqi', 'lgbtq', 'lgbtqi+', 'lgbtqia+', 'lgbtq+'], TRUE)) {
    $slug = 'lgbtqia';
  }
  
  return !empty($slug) ? $slug : 'default';
}

/**
 * Implements hook_preprocess_HOOK() for myeventlane_category_pills theme.
 *
 * Adds category slugs to category pills block template variables.
 */
function myeventlane_theme_preprocess_myeventlane_category_pills(array &$variables): void {
  $categories = $variables['categories'] ?? [];
  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  
  // Add slug to each category item.
  foreach ($categories as $key => $category) {
    $tid = $category['tid'] ?? NULL;
    if ($tid) {
      $term = $term_storage->load($tid);
      if ($term instanceof TermInterface) {
        $slug = _myeventlane_theme_get_category_slug($term);
        $variables['categories'][$key]['slug'] = $slug;
      }
      else {
        $variables['categories'][$key]['slug'] = 'default';
      }
    }
    else {
      $variables['categories'][$key]['slug'] = 'default';
    }
  }
}

/**
 * Implements hook_preprocess_user().
 *
 * Adds classes and context for user forms (login, register, password, edit).
 */
function myeventlane_theme_preprocess_user(array &$variables): void {
  $user = $variables['user'];
  $view_mode = $variables['view_mode'] ?? 'full';

  // Only process form view modes.
  if ($view_mode !== 'form' && $view_mode !== 'default') {
    return;
  }

  $variables['attributes']['class'][] = 'mel-user-form';
}

/**
 * Implements hook_preprocess_entity().
 *
 * Adds classes and context for vendor entity forms.
 */
function myeventlane_theme_preprocess_entity(array &$variables): void {
  $entity = $variables['entity'];
  $view_mode = $variables['view_mode'] ?? 'full';

  // Only process form view modes.
  if ($view_mode !== 'form' && $view_mode !== 'default') {
    return;
  }

  // Check if this is a vendor entity form.
  if ($entity && $entity->getEntityTypeId() === 'myeventlane_vendor') {
    $variables['attributes']['class'][] = 'mel-entity-form';
    $variables['attributes']['class'][] = 'mel-entity-form--vendor';
  }
}

/**
 * Implements hook_form_alter().
 *
 * Adds classes and ensures proper styling for public-facing forms.
 */
function myeventlane_theme_form_alter(array &$form, \Drupal\Core\Form\FormStateInterface $form_state, string $form_id): void {
  // Only apply to front-end theme, not admin theme.
  $theme = \Drupal::theme()->getActiveTheme()->getName();
  if ($theme !== 'myeventlane_theme') {
    return;
  }


  // Event node forms.
  if (in_array($form_id, ['node_event_form', 'node_event_edit_form'])) {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--event';
    
    // Ensure Drupal's form behaviors are attached for #states API
    $form['#attached']['library'][] = 'core/drupal.form';
    $form['#attached']['library'][] = 'core/drupal.states';
    
    // Attach Conditional Fields library if module is enabled
    // This ensures conditional fields work for both admin and vendor forms
    if (\Drupal::moduleHandler()->moduleExists('conditional_fields')) {
      $form['#attached']['library'][] = 'conditional_fields/conditional_fields';
    }
    
    // Attach custom event form enhancements
    $form['#attached']['library'][] = 'myeventlane_theme/event-form';
    
    // Disable Honeypot flood control for event forms (vendors need to save drafts)
    if (isset($form['#attributes']['data-honeypot-time'])) {
      unset($form['#attributes']['data-honeypot-time']);
    }
    
    // Add form token to prevent duplicate submissions without flood control
    if (!isset($form['form_token'])) {
      $form['form_token'] = [
        '#type' => 'token',
        '#default_value' => \Drupal::csrfToken()->get('node_event_form'),
      ];
    }
    
    // Wrap the entire form in our styled container
    // IMPORTANT: Only wrap the form, don't modify field structure to preserve #states API
    $is_edit = ($form_id === 'node_event_edit_form');
    $title = $is_edit ? t('Edit Event') : t('Create New Event');
    $intro = $is_edit 
      ? t('Update your event details below. Changes will be saved when you submit the form.')
      : t('Share your event with the MyEventLane community. Fill out each section below to get started.');
    
    // Get node if editing
    $node = NULL;
    if (isset($form['#entity']) && $form['#entity']) {
      $node = $form['#entity'];
    } elseif ($form_state->getFormObject() && method_exists($form_state->getFormObject(), 'getEntity')) {
      $node = $form_state->getFormObject()->getEntity();
    }
    
    $breadcrumb = '';
    if ($is_edit && $node && !$node->isNew()) {
      $url = $node->toUrl()->toString();
      $breadcrumb = '<nav class="mel-breadcrumb" aria-label="Breadcrumb"><a href="' . $url . '">' . $node->label() . '</a><span class="mel-breadcrumb-separator">/</span><span>Edit</span></nav>';
    }
    
    // Wrap form with styling - this doesn't break #states API as it's outside the form structure
    $form['#prefix'] = '<div class="mel-page-wrapper mel-page-wrapper--form"><div class="mel-container mel-container--form"><div class="mel-form-page-header">' . $breadcrumb . '<h1 class="mel-page-title">' . $title . '</h1><p class="mel-page-intro">' . $intro . '</p></div>';
    $form['#suffix'] = '</div></div>';
    
    // Add wrapper class to form itself
    $form['#attributes']['class'][] = 'mel-event-form-wrapper';
  }

  // User login form.
  if ($form_id === 'user_login_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--login';
  }

  // User register form.
  if ($form_id === 'user_register_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--register';
  }

  // User password reset form.
  if ($form_id === 'user_pass') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--password';
  }

  // User edit form.
  if ($form_id === 'user_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--user-edit';
  }

  // Vendor entity forms.
  if (strpos($form_id, 'myeventlane_vendor') === 0) {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--vendor';
  }
}

/**
 * Preprocess variables for event nodes only.
 */
/**
 * Preprocess event nodes to resolve hero image safely.
 */
function myeventlane_theme_preprocess_node__event(array &$variables): void {
  $node = $variables['node'] ?? NULL;

  if (!$node instanceof NodeInterface) {
    return;
  }

  $file_url_generator = \Drupal::service('file_url_generator');
  $image_url = NULL;

  // 1. Event image field.
  if ($node->hasField('field_event_image') && !$node->get('field_event_image')->isEmpty()) {
    $file = $node->get('field_event_image')->entity;
    if ($file instanceof File) {
      $image_url = $file_url_generator->generateAbsoluteString($file->getFileUri());
    }
  }

  // 2. Category fallback (taxonomy image).
  if (!$image_url && $node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
    $category_field = $node->get('field_category');
    $referenced_entities = $category_field->referencedEntities();
    if (!empty($referenced_entities)) {
      $term = reset($referenced_entities);
      if ($term && $term->hasField('field_category_image') && !$term->get('field_category_image')->isEmpty()) {
        $file = $term->get('field_category_image')->entity;
        if ($file instanceof File) {
          $image_url = $file_url_generator->generateAbsoluteString($file->getFileUri());
        }
      }
    }
  }

  // 3. Hard fallback.
  if (!$image_url) {
    $theme_path = drupal_get_path('theme', 'myeventlane_theme');
    $fallback_path = $theme_path . '/images/mel/placeholders/mel-placeholder-default.png';
    $image_url = '/' . $fallback_path;
  }

  $variables['image_src'] = $image_url;
}

/**
 * Implements hook_preprocess_HOOK() for commerce_cart_form template.
 *
 * Groups cart items by event for better UX and accessibility.
 * Adds event information to form for template rendering.
 */
function myeventlane_theme_preprocess_commerce_cart_form(array &$variables): void {
  $form = $variables['form'];
  
  // Only process if we have order items.
  if (empty($form['#order_items']) || !is_array($form['#order_items'])) {
    return;
  }
  
  $order_items = $form['#order_items'];
  $grouped_items = [];
  $items_without_event = [];
  $item_event_map = [];
  
  // Group items by event and create mapping.
  foreach ($order_items as $order_item) {
    $item_id = (int) $order_item->id();
    
    if (!$order_item->hasField('field_target_event') || $order_item->get('field_target_event')->isEmpty()) {
      // Items without event go to a separate group.
      $items_without_event[] = $order_item;
      $item_event_map[$item_id] = NULL;
      continue;
    }
    
    $event = $order_item->get('field_target_event')->entity;
    if (!$event) {
      $items_without_event[] = $order_item;
      $item_event_map[$item_id] = NULL;
      continue;
    }
    
    $event_id = (int) $event->id();
    $item_event_map[$item_id] = $event_id;
    
    if (!isset($grouped_items[$event_id])) {
      $grouped_items[$event_id] = [
        'event' => $event,
        'items' => [],
        'item_ids' => [],
      ];
    }
    
    $grouped_items[$event_id]['items'][] = $order_item;
    $grouped_items[$event_id]['item_ids'][] = $item_id;
  }
  
  // Add grouped items to variables for template.
  $variables['grouped_items'] = $grouped_items;
  $variables['items_without_event'] = $items_without_event;
  $variables['item_event_map'] = $item_event_map;
}